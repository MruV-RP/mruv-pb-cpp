// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: punishments/punishments.proto
#ifndef GRPC_punishments_2fpunishments_2eproto__INCLUDED
#define GRPC_punishments_2fpunishments_2eproto__INCLUDED

#include "punishments/punishments.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mruv {
namespace punishments {

// This service provides interface for managing punishments for players.
class MruVPunishmentsService final {
 public:
  static constexpr char const* service_full_name() {
    return "mruv.punishments.MruVPunishmentsService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Ban player on account and/or ip.
    // If ban_time is 0, ban will never expire.
    virtual ::grpc::Status Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::mruv::punishments::BanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanResponse>> AsyncBan(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanResponse>>(AsyncBanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanResponse>> PrepareAsyncBan(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanResponse>>(PrepareAsyncBanRaw(context, request, cq));
    }
    // Block player character.
    virtual ::grpc::Status Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::mruv::punishments::BlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockResponse>> AsyncBlock(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockResponse>>(AsyncBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockResponse>> PrepareAsyncBlock(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockResponse>>(PrepareAsyncBlockRaw(context, request, cq));
    }
    // Warn player.
    // If warn_time is 0, warn will never expire.
    virtual ::grpc::Status Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::mruv::punishments::WarnResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnResponse>> AsyncWarn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnResponse>>(AsyncWarnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnResponse>> PrepareAsyncWarn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnResponse>>(PrepareAsyncWarnRaw(context, request, cq));
    }
    // Put player in an admin jail.
    virtual ::grpc::Status AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::mruv::punishments::AdminJailResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::AdminJailResponse>> AsyncAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::AdminJailResponse>>(AsyncAdminJailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::AdminJailResponse>> PrepareAsyncAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::AdminJailResponse>>(PrepareAsyncAdminJailRaw(context, request, cq));
    }
    // Mute player global chats.
    virtual ::grpc::Status MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::mruv::punishments::MuteGlobalChatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::MuteGlobalChatsResponse>> AsyncMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::MuteGlobalChatsResponse>>(AsyncMuteGlobalChatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::MuteGlobalChatsResponse>> PrepareAsyncMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::MuteGlobalChatsResponse>>(PrepareAsyncMuteGlobalChatsRaw(context, request, cq));
    }
    // Deactivate a specific player ban.
    virtual ::grpc::Status UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::mruv::punishments::UnBanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBanResponse>> AsyncUnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBanResponse>>(AsyncUnBanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBanResponse>> PrepareAsyncUnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBanResponse>>(PrepareAsyncUnBanRaw(context, request, cq));
    }
    // Deactivate a character block.
    virtual ::grpc::Status UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::mruv::punishments::UnBlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBlockResponse>> AsyncUnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBlockResponse>>(AsyncUnBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBlockResponse>> PrepareAsyncUnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBlockResponse>>(PrepareAsyncUnBlockRaw(context, request, cq));
    }
    // Deactivate a specific player warning. If a player was banned by reaching the warning limit, a player will be unbanned.
    virtual ::grpc::Status UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::mruv::punishments::UnWarnResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnWarnResponse>> AsyncUnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnWarnResponse>>(AsyncUnWarnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnWarnResponse>> PrepareAsyncUnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnWarnResponse>>(PrepareAsyncUnWarnRaw(context, request, cq));
    }
    // Remove player from admin jail.
    virtual ::grpc::Status UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::mruv::punishments::UnAdminJailResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnAdminJailResponse>> AsyncUnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnAdminJailResponse>>(AsyncUnAdminJailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnAdminJailResponse>> PrepareAsyncUnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnAdminJailResponse>>(PrepareAsyncUnAdminJailRaw(context, request, cq));
    }
    //
    virtual ::grpc::Status UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::mruv::punishments::UnMuteGlobalChatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnMuteGlobalChatsResponse>> AsyncUnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnMuteGlobalChatsResponse>>(AsyncUnMuteGlobalChatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnMuteGlobalChatsResponse>> PrepareAsyncUnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnMuteGlobalChatsResponse>>(PrepareAsyncUnMuteGlobalChatsRaw(context, request, cq));
    }
    // Get all player bans.
    virtual ::grpc::Status GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::mruv::punishments::GetPlayerBansResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerBansResponse>> AsyncGetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerBansResponse>>(AsyncGetPlayerBansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerBansResponse>> PrepareAsyncGetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerBansResponse>>(PrepareAsyncGetPlayerBansRaw(context, request, cq));
    }
    // Get all player warns.
    virtual ::grpc::Status GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::mruv::punishments::GetPlayerWarnsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerWarnsResponse>> AsyncGetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerWarnsResponse>>(AsyncGetPlayerWarnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerWarnsResponse>> PrepareAsyncGetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerWarnsResponse>>(PrepareAsyncGetPlayerWarnsRaw(context, request, cq));
    }
    // Get player admin jail time.
    virtual ::grpc::Status GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::mruv::punishments::GetPlayerAdminJailResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerAdminJailResponse>> AsyncGetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerAdminJailResponse>>(AsyncGetPlayerAdminJailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerAdminJailResponse>> PrepareAsyncGetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerAdminJailResponse>>(PrepareAsyncGetPlayerAdminJailRaw(context, request, cq));
    }
    // Get ban info.
    virtual ::grpc::Status GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::mruv::punishments::BanMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanMessage>> AsyncGetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanMessage>>(AsyncGetBanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanMessage>> PrepareAsyncGetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanMessage>>(PrepareAsyncGetBanRaw(context, request, cq));
    }
    // Get warn info.
    virtual ::grpc::Status GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::mruv::punishments::WarnMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnMessage>> AsyncGetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnMessage>>(AsyncGetWarnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnMessage>> PrepareAsyncGetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnMessage>>(PrepareAsyncGetWarnRaw(context, request, cq));
    }
    // Get block info.
    virtual ::grpc::Status GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::mruv::punishments::BlockMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockMessage>> AsyncGetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockMessage>>(AsyncGetBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockMessage>> PrepareAsyncGetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockMessage>>(PrepareAsyncGetBlockRaw(context, request, cq));
    }
    // Check is player or ip banned.
    virtual ::grpc::Status IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::mruv::punishments::IsPlayerBannedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsPlayerBannedResponse>> AsyncIsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsPlayerBannedResponse>>(AsyncIsPlayerBannedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsPlayerBannedResponse>> PrepareAsyncIsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsPlayerBannedResponse>>(PrepareAsyncIsPlayerBannedRaw(context, request, cq));
    }
    // Check is character is blocked.
    virtual ::grpc::Status IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::mruv::punishments::IsCharacterBlockedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterBlockedResponse>> AsyncIsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterBlockedResponse>>(AsyncIsCharacterBlockedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterBlockedResponse>> PrepareAsyncIsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterBlockedResponse>>(PrepareAsyncIsCharacterBlockedRaw(context, request, cq));
    }
    //
    virtual ::grpc::Status IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::mruv::punishments::IsCharacterJailedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterJailedResponse>> AsyncIsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterJailedResponse>>(AsyncIsCharacterJailedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterJailedResponse>> PrepareAsyncIsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterJailedResponse>>(PrepareAsyncIsCharacterJailedRaw(context, request, cq));
    }
    // Subscribe to ban events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::BanMessage>> WatchBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::BanMessage>>(WatchBansRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BanMessage>> AsyncWatchBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BanMessage>>(AsyncWatchBansRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BanMessage>> PrepareAsyncWatchBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BanMessage>>(PrepareAsyncWatchBansRaw(context, request, cq));
    }
    // Subscribe to block events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::BlockMessage>> WatchBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::BlockMessage>>(WatchBlocksRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BlockMessage>> AsyncWatchBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BlockMessage>>(AsyncWatchBlocksRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BlockMessage>> PrepareAsyncWatchBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BlockMessage>>(PrepareAsyncWatchBlocksRaw(context, request, cq));
    }
    // Subscribe to warn events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WarnMessage>> WatchWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WarnMessage>>(WatchWarnsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WarnMessage>> AsyncWatchWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WarnMessage>>(AsyncWatchWarnsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WarnMessage>> PrepareAsyncWatchWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WarnMessage>>(PrepareAsyncWatchWarnsRaw(context, request, cq));
    }
    // Subscribe to admin jail events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::AdminJailMessage>> WatchAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::AdminJailMessage>>(WatchAdminJailsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::AdminJailMessage>> AsyncWatchAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::AdminJailMessage>>(AsyncWatchAdminJailsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::AdminJailMessage>> PrepareAsyncWatchAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::AdminJailMessage>>(PrepareAsyncWatchAdminJailsRaw(context, request, cq));
    }
    // Subscribe to unban events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnBanMessage>> WatchUnBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnBanMessage>>(WatchUnBansRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBanMessage>> AsyncWatchUnBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBanMessage>>(AsyncWatchUnBansRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBanMessage>> PrepareAsyncWatchUnBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBanMessage>>(PrepareAsyncWatchUnBansRaw(context, request, cq));
    }
    // Subscribe to unblock events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnBlockMessage>> WatchUnBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnBlockMessage>>(WatchUnBlocksRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBlockMessage>> AsyncWatchUnBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBlockMessage>>(AsyncWatchUnBlocksRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBlockMessage>> PrepareAsyncWatchUnBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBlockMessage>>(PrepareAsyncWatchUnBlocksRaw(context, request, cq));
    }
    // Subscribe to unwarn events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnWarnMessage>> WatchUnWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnWarnMessage>>(WatchUnWarnsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnWarnMessage>> AsyncWatchUnWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnWarnMessage>>(AsyncWatchUnWarnsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnWarnMessage>> PrepareAsyncWatchUnWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnWarnMessage>>(PrepareAsyncWatchUnWarnsRaw(context, request, cq));
    }
    // Subscribe to admin jail release events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnAdminJailMessage>> WatchUnAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::UnAdminJailMessage>>(WatchUnAdminJailsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnAdminJailMessage>> AsyncWatchUnAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnAdminJailMessage>>(AsyncWatchUnAdminJailsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnAdminJailMessage>> PrepareAsyncWatchUnAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnAdminJailMessage>>(PrepareAsyncWatchUnAdminJailsRaw(context, request, cq));
    }
    // Subscribe to player punishments.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>> WatchPlayerPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>>(WatchPlayerPunishmentsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>> AsyncWatchPlayerPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>>(AsyncWatchPlayerPunishmentsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>> PrepareAsyncWatchPlayerPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>>(PrepareAsyncWatchPlayerPunishmentsRaw(context, request, cq));
    }
    // Subscribe to player acquittals.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>> WatchPlayerAcquittals(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>>(WatchPlayerAcquittalsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>> AsyncWatchPlayerAcquittals(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>>(AsyncWatchPlayerAcquittalsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>> PrepareAsyncWatchPlayerAcquittals(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>>(PrepareAsyncWatchPlayerAcquittalsRaw(context, request, cq));
    }
    // Subscribe to all punishments and acquittals events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>> WatchPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>>(WatchPunishmentsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>> AsyncWatchPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>>(AsyncWatchPunishmentsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>> PrepareAsyncWatchPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>>(PrepareAsyncWatchPunishmentsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Ban player on account and/or ip.
      // If ban_time is 0, ban will never expire.
      virtual void Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Block player character.
      virtual void Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Warn player.
      // If warn_time is 0, warn will never expire.
      virtual void Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Put player in an admin jail.
      virtual void AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Mute player global chats.
      virtual void MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Deactivate a specific player ban.
      virtual void UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Deactivate a character block.
      virtual void UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Deactivate a specific player warning. If a player was banned by reaching the warning limit, a player will be unbanned.
      virtual void UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove player from admin jail.
      virtual void UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      virtual void UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all player bans.
      virtual void GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all player warns.
      virtual void GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get player admin jail time.
      virtual void GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get ban info.
      virtual void GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get warn info.
      virtual void GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get block info.
      virtual void GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Check is player or ip banned.
      virtual void IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Check is character is blocked.
      virtual void IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      virtual void IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Subscribe to ban events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchBans(::grpc::ClientContext* context, ::mruv::punishments::WatchBansRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::BanMessage>* reactor) = 0;
      #else
      virtual void WatchBans(::grpc::ClientContext* context, ::mruv::punishments::WatchBansRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::BanMessage>* reactor) = 0;
      #endif
      // Subscribe to block events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchBlocksRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::BlockMessage>* reactor) = 0;
      #else
      virtual void WatchBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchBlocksRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::BlockMessage>* reactor) = 0;
      #endif
      // Subscribe to warn events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchWarnsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WarnMessage>* reactor) = 0;
      #else
      virtual void WatchWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchWarnsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WarnMessage>* reactor) = 0;
      #endif
      // Subscribe to admin jail events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchAdminJailsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::AdminJailMessage>* reactor) = 0;
      #else
      virtual void WatchAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchAdminJailsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::AdminJailMessage>* reactor) = 0;
      #endif
      // Subscribe to unban events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchUnBans(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBansRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnBanMessage>* reactor) = 0;
      #else
      virtual void WatchUnBans(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBansRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnBanMessage>* reactor) = 0;
      #endif
      // Subscribe to unblock events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchUnBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBlocksRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnBlockMessage>* reactor) = 0;
      #else
      virtual void WatchUnBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBlocksRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnBlockMessage>* reactor) = 0;
      #endif
      // Subscribe to unwarn events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchUnWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchUnWarnsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnWarnMessage>* reactor) = 0;
      #else
      virtual void WatchUnWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchUnWarnsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnWarnMessage>* reactor) = 0;
      #endif
      // Subscribe to admin jail release events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchUnAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchUnAdminJailsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnAdminJailMessage>* reactor) = 0;
      #else
      virtual void WatchUnAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchUnAdminJailsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnAdminJailMessage>* reactor) = 0;
      #endif
      // Subscribe to player punishments.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchPlayerPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerPunishmentsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WatchPlayerPunishmentsResponse>* reactor) = 0;
      #else
      virtual void WatchPlayerPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerPunishmentsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WatchPlayerPunishmentsResponse>* reactor) = 0;
      #endif
      // Subscribe to player acquittals.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchPlayerAcquittals(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerAcquittalsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WatchPlayerAcquittalsResponse>* reactor) = 0;
      #else
      virtual void WatchPlayerAcquittals(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerAcquittalsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WatchPlayerAcquittalsResponse>* reactor) = 0;
      #endif
      // Subscribe to all punishments and acquittals events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPunishmentsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WatchPunishmentsResponse>* reactor) = 0;
      #else
      virtual void WatchPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPunishmentsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WatchPunishmentsResponse>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanResponse>* AsyncBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanResponse>* PrepareAsyncBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockResponse>* AsyncBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockResponse>* PrepareAsyncBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnResponse>* AsyncWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnResponse>* PrepareAsyncWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::AdminJailResponse>* AsyncAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::AdminJailResponse>* PrepareAsyncAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::MuteGlobalChatsResponse>* AsyncMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::MuteGlobalChatsResponse>* PrepareAsyncMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBanResponse>* AsyncUnBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBanResponse>* PrepareAsyncUnBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBlockResponse>* AsyncUnBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnBlockResponse>* PrepareAsyncUnBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnWarnResponse>* AsyncUnWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnWarnResponse>* PrepareAsyncUnWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnAdminJailResponse>* AsyncUnAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnAdminJailResponse>* PrepareAsyncUnAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnMuteGlobalChatsResponse>* AsyncUnMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::UnMuteGlobalChatsResponse>* PrepareAsyncUnMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerBansResponse>* AsyncGetPlayerBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerBansResponse>* PrepareAsyncGetPlayerBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerWarnsResponse>* AsyncGetPlayerWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerWarnsResponse>* PrepareAsyncGetPlayerWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerAdminJailResponse>* AsyncGetPlayerAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::GetPlayerAdminJailResponse>* PrepareAsyncGetPlayerAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanMessage>* AsyncGetBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BanMessage>* PrepareAsyncGetBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnMessage>* AsyncGetWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::WarnMessage>* PrepareAsyncGetWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockMessage>* AsyncGetBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::BlockMessage>* PrepareAsyncGetBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsPlayerBannedResponse>* AsyncIsPlayerBannedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsPlayerBannedResponse>* PrepareAsyncIsPlayerBannedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterBlockedResponse>* AsyncIsCharacterBlockedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterBlockedResponse>* PrepareAsyncIsCharacterBlockedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterJailedResponse>* AsyncIsCharacterJailedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::punishments::IsCharacterJailedResponse>* PrepareAsyncIsCharacterJailedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::BanMessage>* WatchBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BanMessage>* AsyncWatchBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BanMessage>* PrepareAsyncWatchBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::BlockMessage>* WatchBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BlockMessage>* AsyncWatchBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::BlockMessage>* PrepareAsyncWatchBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::WarnMessage>* WatchWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WarnMessage>* AsyncWatchWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WarnMessage>* PrepareAsyncWatchWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::AdminJailMessage>* WatchAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::AdminJailMessage>* AsyncWatchAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::AdminJailMessage>* PrepareAsyncWatchAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::UnBanMessage>* WatchUnBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBanMessage>* AsyncWatchUnBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBanMessage>* PrepareAsyncWatchUnBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::UnBlockMessage>* WatchUnBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBlockMessage>* AsyncWatchUnBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnBlockMessage>* PrepareAsyncWatchUnBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::UnWarnMessage>* WatchUnWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnWarnMessage>* AsyncWatchUnWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnWarnMessage>* PrepareAsyncWatchUnWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::UnAdminJailMessage>* WatchUnAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnAdminJailMessage>* AsyncWatchUnAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::UnAdminJailMessage>* PrepareAsyncWatchUnAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>* WatchPlayerPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>* AsyncWatchPlayerPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerPunishmentsResponse>* PrepareAsyncWatchPlayerPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>* WatchPlayerAcquittalsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>* AsyncWatchPlayerAcquittalsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPlayerAcquittalsResponse>* PrepareAsyncWatchPlayerAcquittalsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>* WatchPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>* AsyncWatchPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::punishments::WatchPunishmentsResponse>* PrepareAsyncWatchPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::mruv::punishments::BanResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanResponse>> AsyncBan(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanResponse>>(AsyncBanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanResponse>> PrepareAsyncBan(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanResponse>>(PrepareAsyncBanRaw(context, request, cq));
    }
    ::grpc::Status Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::mruv::punishments::BlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockResponse>> AsyncBlock(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockResponse>>(AsyncBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockResponse>> PrepareAsyncBlock(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockResponse>>(PrepareAsyncBlockRaw(context, request, cq));
    }
    ::grpc::Status Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::mruv::punishments::WarnResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnResponse>> AsyncWarn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnResponse>>(AsyncWarnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnResponse>> PrepareAsyncWarn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnResponse>>(PrepareAsyncWarnRaw(context, request, cq));
    }
    ::grpc::Status AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::mruv::punishments::AdminJailResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::AdminJailResponse>> AsyncAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::AdminJailResponse>>(AsyncAdminJailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::AdminJailResponse>> PrepareAsyncAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::AdminJailResponse>>(PrepareAsyncAdminJailRaw(context, request, cq));
    }
    ::grpc::Status MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::mruv::punishments::MuteGlobalChatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::MuteGlobalChatsResponse>> AsyncMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::MuteGlobalChatsResponse>>(AsyncMuteGlobalChatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::MuteGlobalChatsResponse>> PrepareAsyncMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::MuteGlobalChatsResponse>>(PrepareAsyncMuteGlobalChatsRaw(context, request, cq));
    }
    ::grpc::Status UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::mruv::punishments::UnBanResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBanResponse>> AsyncUnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBanResponse>>(AsyncUnBanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBanResponse>> PrepareAsyncUnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBanResponse>>(PrepareAsyncUnBanRaw(context, request, cq));
    }
    ::grpc::Status UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::mruv::punishments::UnBlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBlockResponse>> AsyncUnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBlockResponse>>(AsyncUnBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBlockResponse>> PrepareAsyncUnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBlockResponse>>(PrepareAsyncUnBlockRaw(context, request, cq));
    }
    ::grpc::Status UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::mruv::punishments::UnWarnResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnWarnResponse>> AsyncUnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnWarnResponse>>(AsyncUnWarnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnWarnResponse>> PrepareAsyncUnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnWarnResponse>>(PrepareAsyncUnWarnRaw(context, request, cq));
    }
    ::grpc::Status UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::mruv::punishments::UnAdminJailResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnAdminJailResponse>> AsyncUnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnAdminJailResponse>>(AsyncUnAdminJailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnAdminJailResponse>> PrepareAsyncUnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnAdminJailResponse>>(PrepareAsyncUnAdminJailRaw(context, request, cq));
    }
    ::grpc::Status UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::mruv::punishments::UnMuteGlobalChatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnMuteGlobalChatsResponse>> AsyncUnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnMuteGlobalChatsResponse>>(AsyncUnMuteGlobalChatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnMuteGlobalChatsResponse>> PrepareAsyncUnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnMuteGlobalChatsResponse>>(PrepareAsyncUnMuteGlobalChatsRaw(context, request, cq));
    }
    ::grpc::Status GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::mruv::punishments::GetPlayerBansResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerBansResponse>> AsyncGetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerBansResponse>>(AsyncGetPlayerBansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerBansResponse>> PrepareAsyncGetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerBansResponse>>(PrepareAsyncGetPlayerBansRaw(context, request, cq));
    }
    ::grpc::Status GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::mruv::punishments::GetPlayerWarnsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerWarnsResponse>> AsyncGetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerWarnsResponse>>(AsyncGetPlayerWarnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerWarnsResponse>> PrepareAsyncGetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerWarnsResponse>>(PrepareAsyncGetPlayerWarnsRaw(context, request, cq));
    }
    ::grpc::Status GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::mruv::punishments::GetPlayerAdminJailResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerAdminJailResponse>> AsyncGetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerAdminJailResponse>>(AsyncGetPlayerAdminJailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerAdminJailResponse>> PrepareAsyncGetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerAdminJailResponse>>(PrepareAsyncGetPlayerAdminJailRaw(context, request, cq));
    }
    ::grpc::Status GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::mruv::punishments::BanMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanMessage>> AsyncGetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanMessage>>(AsyncGetBanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanMessage>> PrepareAsyncGetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanMessage>>(PrepareAsyncGetBanRaw(context, request, cq));
    }
    ::grpc::Status GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::mruv::punishments::WarnMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnMessage>> AsyncGetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnMessage>>(AsyncGetWarnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnMessage>> PrepareAsyncGetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnMessage>>(PrepareAsyncGetWarnRaw(context, request, cq));
    }
    ::grpc::Status GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::mruv::punishments::BlockMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockMessage>> AsyncGetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockMessage>>(AsyncGetBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockMessage>> PrepareAsyncGetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockMessage>>(PrepareAsyncGetBlockRaw(context, request, cq));
    }
    ::grpc::Status IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::mruv::punishments::IsPlayerBannedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsPlayerBannedResponse>> AsyncIsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsPlayerBannedResponse>>(AsyncIsPlayerBannedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsPlayerBannedResponse>> PrepareAsyncIsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsPlayerBannedResponse>>(PrepareAsyncIsPlayerBannedRaw(context, request, cq));
    }
    ::grpc::Status IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::mruv::punishments::IsCharacterBlockedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterBlockedResponse>> AsyncIsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterBlockedResponse>>(AsyncIsCharacterBlockedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterBlockedResponse>> PrepareAsyncIsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterBlockedResponse>>(PrepareAsyncIsCharacterBlockedRaw(context, request, cq));
    }
    ::grpc::Status IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::mruv::punishments::IsCharacterJailedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterJailedResponse>> AsyncIsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterJailedResponse>>(AsyncIsCharacterJailedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterJailedResponse>> PrepareAsyncIsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterJailedResponse>>(PrepareAsyncIsCharacterJailedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::BanMessage>> WatchBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::BanMessage>>(WatchBansRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BanMessage>> AsyncWatchBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BanMessage>>(AsyncWatchBansRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BanMessage>> PrepareAsyncWatchBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BanMessage>>(PrepareAsyncWatchBansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::BlockMessage>> WatchBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::BlockMessage>>(WatchBlocksRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BlockMessage>> AsyncWatchBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BlockMessage>>(AsyncWatchBlocksRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BlockMessage>> PrepareAsyncWatchBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::BlockMessage>>(PrepareAsyncWatchBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WarnMessage>> WatchWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WarnMessage>>(WatchWarnsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WarnMessage>> AsyncWatchWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WarnMessage>>(AsyncWatchWarnsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WarnMessage>> PrepareAsyncWatchWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WarnMessage>>(PrepareAsyncWatchWarnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::AdminJailMessage>> WatchAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::AdminJailMessage>>(WatchAdminJailsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::AdminJailMessage>> AsyncWatchAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::AdminJailMessage>>(AsyncWatchAdminJailsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::AdminJailMessage>> PrepareAsyncWatchAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::AdminJailMessage>>(PrepareAsyncWatchAdminJailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnBanMessage>> WatchUnBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnBanMessage>>(WatchUnBansRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBanMessage>> AsyncWatchUnBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBanMessage>>(AsyncWatchUnBansRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBanMessage>> PrepareAsyncWatchUnBans(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBanMessage>>(PrepareAsyncWatchUnBansRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnBlockMessage>> WatchUnBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnBlockMessage>>(WatchUnBlocksRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBlockMessage>> AsyncWatchUnBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBlockMessage>>(AsyncWatchUnBlocksRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBlockMessage>> PrepareAsyncWatchUnBlocks(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnBlockMessage>>(PrepareAsyncWatchUnBlocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnWarnMessage>> WatchUnWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnWarnMessage>>(WatchUnWarnsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnWarnMessage>> AsyncWatchUnWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnWarnMessage>>(AsyncWatchUnWarnsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnWarnMessage>> PrepareAsyncWatchUnWarns(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnWarnMessage>>(PrepareAsyncWatchUnWarnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnAdminJailMessage>> WatchUnAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::UnAdminJailMessage>>(WatchUnAdminJailsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnAdminJailMessage>> AsyncWatchUnAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnAdminJailMessage>>(AsyncWatchUnAdminJailsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnAdminJailMessage>> PrepareAsyncWatchUnAdminJails(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::UnAdminJailMessage>>(PrepareAsyncWatchUnAdminJailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>> WatchPlayerPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>>(WatchPlayerPunishmentsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>> AsyncWatchPlayerPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>>(AsyncWatchPlayerPunishmentsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>> PrepareAsyncWatchPlayerPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>>(PrepareAsyncWatchPlayerPunishmentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>> WatchPlayerAcquittals(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>>(WatchPlayerAcquittalsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>> AsyncWatchPlayerAcquittals(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>>(AsyncWatchPlayerAcquittalsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>> PrepareAsyncWatchPlayerAcquittals(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>>(PrepareAsyncWatchPlayerAcquittalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WatchPunishmentsResponse>> WatchPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::punishments::WatchPunishmentsResponse>>(WatchPunishmentsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPunishmentsResponse>> AsyncWatchPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPunishmentsResponse>>(AsyncWatchPunishmentsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPunishmentsResponse>> PrepareAsyncWatchPunishments(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPunishmentsResponse>>(PrepareAsyncWatchPunishmentsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Ban(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Block(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Warn(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AdminJail(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnBan(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnBlock(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnWarn(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnMuteGlobalChats(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPlayerBans(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPlayerWarns(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPlayerAdminJail(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBan(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetWarn(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlock(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void IsPlayerBanned(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void IsCharacterBlocked(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void IsCharacterJailed(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchBans(::grpc::ClientContext* context, ::mruv::punishments::WatchBansRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::BanMessage>* reactor) override;
      #else
      void WatchBans(::grpc::ClientContext* context, ::mruv::punishments::WatchBansRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::BanMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchBlocksRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::BlockMessage>* reactor) override;
      #else
      void WatchBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchBlocksRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::BlockMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchWarnsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WarnMessage>* reactor) override;
      #else
      void WatchWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchWarnsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WarnMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchAdminJailsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::AdminJailMessage>* reactor) override;
      #else
      void WatchAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchAdminJailsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::AdminJailMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchUnBans(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBansRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnBanMessage>* reactor) override;
      #else
      void WatchUnBans(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBansRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnBanMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchUnBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBlocksRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnBlockMessage>* reactor) override;
      #else
      void WatchUnBlocks(::grpc::ClientContext* context, ::mruv::punishments::WatchUnBlocksRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnBlockMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchUnWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchUnWarnsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnWarnMessage>* reactor) override;
      #else
      void WatchUnWarns(::grpc::ClientContext* context, ::mruv::punishments::WatchUnWarnsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnWarnMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchUnAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchUnAdminJailsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::UnAdminJailMessage>* reactor) override;
      #else
      void WatchUnAdminJails(::grpc::ClientContext* context, ::mruv::punishments::WatchUnAdminJailsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::UnAdminJailMessage>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchPlayerPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerPunishmentsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WatchPlayerPunishmentsResponse>* reactor) override;
      #else
      void WatchPlayerPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerPunishmentsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WatchPlayerPunishmentsResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchPlayerAcquittals(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerAcquittalsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WatchPlayerAcquittalsResponse>* reactor) override;
      #else
      void WatchPlayerAcquittals(::grpc::ClientContext* context, ::mruv::punishments::WatchPlayerAcquittalsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WatchPlayerAcquittalsResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPunishmentsRequest* request, ::grpc::ClientReadReactor< ::mruv::punishments::WatchPunishmentsResponse>* reactor) override;
      #else
      void WatchPunishments(::grpc::ClientContext* context, ::mruv::punishments::WatchPunishmentsRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::punishments::WatchPunishmentsResponse>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanResponse>* AsyncBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanResponse>* PrepareAsyncBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::BanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockResponse>* AsyncBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockResponse>* PrepareAsyncBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::BlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnResponse>* AsyncWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnResponse>* PrepareAsyncWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::WarnRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::AdminJailResponse>* AsyncAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::AdminJailResponse>* PrepareAsyncAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::AdminJailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::MuteGlobalChatsResponse>* AsyncMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::MuteGlobalChatsResponse>* PrepareAsyncMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::MuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBanResponse>* AsyncUnBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBanResponse>* PrepareAsyncUnBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBlockResponse>* AsyncUnBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnBlockResponse>* PrepareAsyncUnBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnWarnResponse>* AsyncUnWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnWarnResponse>* PrepareAsyncUnWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnWarnRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnAdminJailResponse>* AsyncUnAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnAdminJailResponse>* PrepareAsyncUnAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnAdminJailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnMuteGlobalChatsResponse>* AsyncUnMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::UnMuteGlobalChatsResponse>* PrepareAsyncUnMuteGlobalChatsRaw(::grpc::ClientContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerBansResponse>* AsyncGetPlayerBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerBansResponse>* PrepareAsyncGetPlayerBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerBansRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerWarnsResponse>* AsyncGetPlayerWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerWarnsResponse>* PrepareAsyncGetPlayerWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerWarnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerAdminJailResponse>* AsyncGetPlayerAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::GetPlayerAdminJailResponse>* PrepareAsyncGetPlayerAdminJailRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanMessage>* AsyncGetBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BanMessage>* PrepareAsyncGetBanRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnMessage>* AsyncGetWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::WarnMessage>* PrepareAsyncGetWarnRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetWarnRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockMessage>* AsyncGetBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::BlockMessage>* PrepareAsyncGetBlockRaw(::grpc::ClientContext* context, const ::mruv::punishments::GetBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsPlayerBannedResponse>* AsyncIsPlayerBannedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsPlayerBannedResponse>* PrepareAsyncIsPlayerBannedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsPlayerBannedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterBlockedResponse>* AsyncIsCharacterBlockedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterBlockedResponse>* PrepareAsyncIsCharacterBlockedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterBlockedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterJailedResponse>* AsyncIsCharacterJailedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::punishments::IsCharacterJailedResponse>* PrepareAsyncIsCharacterJailedRaw(::grpc::ClientContext* context, const ::mruv::punishments::IsCharacterJailedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::BanMessage>* WatchBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::BanMessage>* AsyncWatchBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::BanMessage>* PrepareAsyncWatchBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBansRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::BlockMessage>* WatchBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::BlockMessage>* AsyncWatchBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::BlockMessage>* PrepareAsyncWatchBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::WarnMessage>* WatchWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WarnMessage>* AsyncWatchWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WarnMessage>* PrepareAsyncWatchWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchWarnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::AdminJailMessage>* WatchAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::AdminJailMessage>* AsyncWatchAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::AdminJailMessage>* PrepareAsyncWatchAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchAdminJailsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::UnBanMessage>* WatchUnBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnBanMessage>* AsyncWatchUnBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnBanMessage>* PrepareAsyncWatchUnBansRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBansRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::UnBlockMessage>* WatchUnBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnBlockMessage>* AsyncWatchUnBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnBlockMessage>* PrepareAsyncWatchUnBlocksRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnBlocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::UnWarnMessage>* WatchUnWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnWarnMessage>* AsyncWatchUnWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnWarnMessage>* PrepareAsyncWatchUnWarnsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnWarnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::UnAdminJailMessage>* WatchUnAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnAdminJailMessage>* AsyncWatchUnAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::UnAdminJailMessage>* PrepareAsyncWatchUnAdminJailsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>* WatchPlayerPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>* AsyncWatchPlayerPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerPunishmentsResponse>* PrepareAsyncWatchPlayerPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>* WatchPlayerAcquittalsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>* AsyncWatchPlayerAcquittalsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPlayerAcquittalsResponse>* PrepareAsyncWatchPlayerAcquittalsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::punishments::WatchPunishmentsResponse>* WatchPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPunishmentsResponse>* AsyncWatchPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::punishments::WatchPunishmentsResponse>* PrepareAsyncWatchPunishmentsRaw(::grpc::ClientContext* context, const ::mruv::punishments::WatchPunishmentsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Ban_;
    const ::grpc::internal::RpcMethod rpcmethod_Block_;
    const ::grpc::internal::RpcMethod rpcmethod_Warn_;
    const ::grpc::internal::RpcMethod rpcmethod_AdminJail_;
    const ::grpc::internal::RpcMethod rpcmethod_MuteGlobalChats_;
    const ::grpc::internal::RpcMethod rpcmethod_UnBan_;
    const ::grpc::internal::RpcMethod rpcmethod_UnBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_UnWarn_;
    const ::grpc::internal::RpcMethod rpcmethod_UnAdminJail_;
    const ::grpc::internal::RpcMethod rpcmethod_UnMuteGlobalChats_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayerBans_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayerWarns_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayerAdminJail_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBan_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWarn_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_IsPlayerBanned_;
    const ::grpc::internal::RpcMethod rpcmethod_IsCharacterBlocked_;
    const ::grpc::internal::RpcMethod rpcmethod_IsCharacterJailed_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchBans_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchWarns_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchAdminJails_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchUnBans_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchUnBlocks_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchUnWarns_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchUnAdminJails_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchPlayerPunishments_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchPlayerAcquittals_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchPunishments_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Ban player on account and/or ip.
    // If ban_time is 0, ban will never expire.
    virtual ::grpc::Status Ban(::grpc::ServerContext* context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response);
    // Block player character.
    virtual ::grpc::Status Block(::grpc::ServerContext* context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response);
    // Warn player.
    // If warn_time is 0, warn will never expire.
    virtual ::grpc::Status Warn(::grpc::ServerContext* context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response);
    // Put player in an admin jail.
    virtual ::grpc::Status AdminJail(::grpc::ServerContext* context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response);
    // Mute player global chats.
    virtual ::grpc::Status MuteGlobalChats(::grpc::ServerContext* context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response);
    // Deactivate a specific player ban.
    virtual ::grpc::Status UnBan(::grpc::ServerContext* context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response);
    // Deactivate a character block.
    virtual ::grpc::Status UnBlock(::grpc::ServerContext* context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response);
    // Deactivate a specific player warning. If a player was banned by reaching the warning limit, a player will be unbanned.
    virtual ::grpc::Status UnWarn(::grpc::ServerContext* context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response);
    // Remove player from admin jail.
    virtual ::grpc::Status UnAdminJail(::grpc::ServerContext* context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response);
    //
    virtual ::grpc::Status UnMuteGlobalChats(::grpc::ServerContext* context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response);
    // Get all player bans.
    virtual ::grpc::Status GetPlayerBans(::grpc::ServerContext* context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response);
    // Get all player warns.
    virtual ::grpc::Status GetPlayerWarns(::grpc::ServerContext* context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response);
    // Get player admin jail time.
    virtual ::grpc::Status GetPlayerAdminJail(::grpc::ServerContext* context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response);
    // Get ban info.
    virtual ::grpc::Status GetBan(::grpc::ServerContext* context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response);
    // Get warn info.
    virtual ::grpc::Status GetWarn(::grpc::ServerContext* context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response);
    // Get block info.
    virtual ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response);
    // Check is player or ip banned.
    virtual ::grpc::Status IsPlayerBanned(::grpc::ServerContext* context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response);
    // Check is character is blocked.
    virtual ::grpc::Status IsCharacterBlocked(::grpc::ServerContext* context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response);
    //
    virtual ::grpc::Status IsCharacterJailed(::grpc::ServerContext* context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response);
    // Subscribe to ban events.
    virtual ::grpc::Status WatchBans(::grpc::ServerContext* context, const ::mruv::punishments::WatchBansRequest* request, ::grpc::ServerWriter< ::mruv::punishments::BanMessage>* writer);
    // Subscribe to block events.
    virtual ::grpc::Status WatchBlocks(::grpc::ServerContext* context, const ::mruv::punishments::WatchBlocksRequest* request, ::grpc::ServerWriter< ::mruv::punishments::BlockMessage>* writer);
    // Subscribe to warn events.
    virtual ::grpc::Status WatchWarns(::grpc::ServerContext* context, const ::mruv::punishments::WatchWarnsRequest* request, ::grpc::ServerWriter< ::mruv::punishments::WarnMessage>* writer);
    // Subscribe to admin jail events.
    virtual ::grpc::Status WatchAdminJails(::grpc::ServerContext* context, const ::mruv::punishments::WatchAdminJailsRequest* request, ::grpc::ServerWriter< ::mruv::punishments::AdminJailMessage>* writer);
    // Subscribe to unban events.
    virtual ::grpc::Status WatchUnBans(::grpc::ServerContext* context, const ::mruv::punishments::WatchUnBansRequest* request, ::grpc::ServerWriter< ::mruv::punishments::UnBanMessage>* writer);
    // Subscribe to unblock events.
    virtual ::grpc::Status WatchUnBlocks(::grpc::ServerContext* context, const ::mruv::punishments::WatchUnBlocksRequest* request, ::grpc::ServerWriter< ::mruv::punishments::UnBlockMessage>* writer);
    // Subscribe to unwarn events.
    virtual ::grpc::Status WatchUnWarns(::grpc::ServerContext* context, const ::mruv::punishments::WatchUnWarnsRequest* request, ::grpc::ServerWriter< ::mruv::punishments::UnWarnMessage>* writer);
    // Subscribe to admin jail release events.
    virtual ::grpc::Status WatchUnAdminJails(::grpc::ServerContext* context, const ::mruv::punishments::WatchUnAdminJailsRequest* request, ::grpc::ServerWriter< ::mruv::punishments::UnAdminJailMessage>* writer);
    // Subscribe to player punishments.
    virtual ::grpc::Status WatchPlayerPunishments(::grpc::ServerContext* context, const ::mruv::punishments::WatchPlayerPunishmentsRequest* request, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* writer);
    // Subscribe to player acquittals.
    virtual ::grpc::Status WatchPlayerAcquittals(::grpc::ServerContext* context, const ::mruv::punishments::WatchPlayerAcquittalsRequest* request, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* writer);
    // Subscribe to all punishments and acquittals events.
    virtual ::grpc::Status WatchPunishments(::grpc::ServerContext* context, const ::mruv::punishments::WatchPunishmentsRequest* request, ::grpc::ServerWriter< ::mruv::punishments::WatchPunishmentsResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_Ban : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ban() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Ban() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ban(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBan(::grpc::ServerContext* context, ::mruv::punishments::BanRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::BanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Block() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlock(::grpc::ServerContext* context, ::mruv::punishments::BlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::BlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Warn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Warn() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Warn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Warn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWarn(::grpc::ServerContext* context, ::mruv::punishments::WarnRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::WarnResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AdminJail() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_AdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAdminJail(::grpc::ServerContext* context, ::mruv::punishments::AdminJailRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::AdminJailResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MuteGlobalChats() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMuteGlobalChats(::grpc::ServerContext* context, ::mruv::punishments::MuteGlobalChatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::MuteGlobalChatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnBan() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_UnBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnBan(::grpc::ServerContext* context, ::mruv::punishments::UnBanRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::UnBanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnBlock() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UnBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnBlock(::grpc::ServerContext* context, ::mruv::punishments::UnBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::UnBlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnWarn() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_UnWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnWarn(::grpc::ServerContext* context, ::mruv::punishments::UnWarnRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::UnWarnResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnAdminJail() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_UnAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnAdminJail(::grpc::ServerContext* context, ::mruv::punishments::UnAdminJailRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::UnAdminJailResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnMuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnMuteGlobalChats() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_UnMuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnMuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnMuteGlobalChats(::grpc::ServerContext* context, ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::UnMuteGlobalChatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayerBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayerBans() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetPlayerBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerBans(::grpc::ServerContext* context, ::mruv::punishments::GetPlayerBansRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::GetPlayerBansResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayerWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayerWarns() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetPlayerWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerWarns(::grpc::ServerContext* context, ::mruv::punishments::GetPlayerWarnsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::GetPlayerWarnsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayerAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayerAdminJail() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetPlayerAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerAdminJail(::grpc::ServerContext* context, ::mruv::punishments::GetPlayerAdminJailRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::GetPlayerAdminJailResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBan() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBan(::grpc::ServerContext* context, ::mruv::punishments::GetBanRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::BanMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWarn() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWarn(::grpc::ServerContext* context, ::mruv::punishments::GetWarnRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::WarnMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlock() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlock(::grpc::ServerContext* context, ::mruv::punishments::GetBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::BlockMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsPlayerBanned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsPlayerBanned() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_IsPlayerBanned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsPlayerBanned(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsPlayerBanned(::grpc::ServerContext* context, ::mruv::punishments::IsPlayerBannedRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::IsPlayerBannedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsCharacterBlocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsCharacterBlocked() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_IsCharacterBlocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterBlocked(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsCharacterBlocked(::grpc::ServerContext* context, ::mruv::punishments::IsCharacterBlockedRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::IsCharacterBlockedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsCharacterJailed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsCharacterJailed() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_IsCharacterJailed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterJailed(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsCharacterJailed(::grpc::ServerContext* context, ::mruv::punishments::IsCharacterJailedRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::punishments::IsCharacterJailedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchBans() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_WatchBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBans(::grpc::ServerContext* context, ::mruv::punishments::WatchBansRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::BanMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(19, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchBlocks() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_WatchBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBlocks(::grpc::ServerContext* context, ::mruv::punishments::WatchBlocksRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::BlockMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(20, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchWarns() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_WatchWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchWarns(::grpc::ServerContext* context, ::mruv::punishments::WatchWarnsRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::WarnMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(21, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchAdminJails() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_WatchAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::AdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchAdminJails(::grpc::ServerContext* context, ::mruv::punishments::WatchAdminJailsRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::AdminJailMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchUnBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchUnBans() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_WatchUnBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnBans(::grpc::ServerContext* context, ::mruv::punishments::WatchUnBansRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::UnBanMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(23, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchUnBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchUnBlocks() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_WatchUnBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnBlocks(::grpc::ServerContext* context, ::mruv::punishments::WatchUnBlocksRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::UnBlockMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchUnWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchUnWarns() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_WatchUnWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnWarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnWarns(::grpc::ServerContext* context, ::mruv::punishments::WatchUnWarnsRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::UnWarnMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchUnAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchUnAdminJails() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_WatchUnAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnAdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnAdminJails(::grpc::ServerContext* context, ::mruv::punishments::WatchUnAdminJailsRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::UnAdminJailMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(26, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchPlayerPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchPlayerPunishments() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_WatchPlayerPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchPlayerPunishments(::grpc::ServerContext* context, ::mruv::punishments::WatchPlayerPunishmentsRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(27, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchPlayerAcquittals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchPlayerAcquittals() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_WatchPlayerAcquittals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerAcquittals(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchPlayerAcquittals(::grpc::ServerContext* context, ::mruv::punishments::WatchPlayerAcquittalsRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(28, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchPunishments() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_WatchPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchPunishments(::grpc::ServerContext* context, ::mruv::punishments::WatchPunishmentsRequest* request, ::grpc::ServerAsyncWriter< ::mruv::punishments::WatchPunishmentsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(29, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Ban<WithAsyncMethod_Block<WithAsyncMethod_Warn<WithAsyncMethod_AdminJail<WithAsyncMethod_MuteGlobalChats<WithAsyncMethod_UnBan<WithAsyncMethod_UnBlock<WithAsyncMethod_UnWarn<WithAsyncMethod_UnAdminJail<WithAsyncMethod_UnMuteGlobalChats<WithAsyncMethod_GetPlayerBans<WithAsyncMethod_GetPlayerWarns<WithAsyncMethod_GetPlayerAdminJail<WithAsyncMethod_GetBan<WithAsyncMethod_GetWarn<WithAsyncMethod_GetBlock<WithAsyncMethod_IsPlayerBanned<WithAsyncMethod_IsCharacterBlocked<WithAsyncMethod_IsCharacterJailed<WithAsyncMethod_WatchBans<WithAsyncMethod_WatchBlocks<WithAsyncMethod_WatchWarns<WithAsyncMethod_WatchAdminJails<WithAsyncMethod_WatchUnBans<WithAsyncMethod_WatchUnBlocks<WithAsyncMethod_WatchUnWarns<WithAsyncMethod_WatchUnAdminJails<WithAsyncMethod_WatchPlayerPunishments<WithAsyncMethod_WatchPlayerAcquittals<WithAsyncMethod_WatchPunishments<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Ban : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Ban() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::BanRequest, ::mruv::punishments::BanResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::BanRequest* request, ::mruv::punishments::BanResponse* response) { return this->Ban(context, request, response); }));}
    void SetMessageAllocatorFor_Ban(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::BanRequest, ::mruv::punishments::BanResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::BanRequest, ::mruv::punishments::BanResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Ban() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ban(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ban(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ban(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Block() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::BlockRequest, ::mruv::punishments::BlockResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::BlockRequest* request, ::mruv::punishments::BlockResponse* response) { return this->Block(context, request, response); }));}
    void SetMessageAllocatorFor_Block(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::BlockRequest, ::mruv::punishments::BlockResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::BlockRequest, ::mruv::punishments::BlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Block(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Block(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Warn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Warn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::WarnRequest, ::mruv::punishments::WarnResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WarnRequest* request, ::mruv::punishments::WarnResponse* response) { return this->Warn(context, request, response); }));}
    void SetMessageAllocatorFor_Warn(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::WarnRequest, ::mruv::punishments::WarnResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::WarnRequest, ::mruv::punishments::WarnResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Warn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Warn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Warn(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Warn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AdminJail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::AdminJailRequest, ::mruv::punishments::AdminJailResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::AdminJailRequest* request, ::mruv::punishments::AdminJailResponse* response) { return this->AdminJail(context, request, response); }));}
    void SetMessageAllocatorFor_AdminJail(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::AdminJailRequest, ::mruv::punishments::AdminJailResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::AdminJailRequest, ::mruv::punishments::AdminJailResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AdminJail(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AdminJail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MuteGlobalChats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::MuteGlobalChatsRequest, ::mruv::punishments::MuteGlobalChatsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::MuteGlobalChatsRequest* request, ::mruv::punishments::MuteGlobalChatsResponse* response) { return this->MuteGlobalChats(context, request, response); }));}
    void SetMessageAllocatorFor_MuteGlobalChats(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::MuteGlobalChatsRequest, ::mruv::punishments::MuteGlobalChatsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::MuteGlobalChatsRequest, ::mruv::punishments::MuteGlobalChatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MuteGlobalChats(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MuteGlobalChats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnBan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnBanRequest, ::mruv::punishments::UnBanResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::UnBanRequest* request, ::mruv::punishments::UnBanResponse* response) { return this->UnBan(context, request, response); }));}
    void SetMessageAllocatorFor_UnBan(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::UnBanRequest, ::mruv::punishments::UnBanResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnBanRequest, ::mruv::punishments::UnBanResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnBan(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnBan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnBlockRequest, ::mruv::punishments::UnBlockResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::UnBlockRequest* request, ::mruv::punishments::UnBlockResponse* response) { return this->UnBlock(context, request, response); }));}
    void SetMessageAllocatorFor_UnBlock(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::UnBlockRequest, ::mruv::punishments::UnBlockResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnBlockRequest, ::mruv::punishments::UnBlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnWarn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnWarnRequest, ::mruv::punishments::UnWarnResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::UnWarnRequest* request, ::mruv::punishments::UnWarnResponse* response) { return this->UnWarn(context, request, response); }));}
    void SetMessageAllocatorFor_UnWarn(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::UnWarnRequest, ::mruv::punishments::UnWarnResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnWarnRequest, ::mruv::punishments::UnWarnResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnWarn(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnWarn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnAdminJail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnAdminJailRequest, ::mruv::punishments::UnAdminJailResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::UnAdminJailRequest* request, ::mruv::punishments::UnAdminJailResponse* response) { return this->UnAdminJail(context, request, response); }));}
    void SetMessageAllocatorFor_UnAdminJail(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::UnAdminJailRequest, ::mruv::punishments::UnAdminJailResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnAdminJailRequest, ::mruv::punishments::UnAdminJailResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnAdminJail(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnAdminJail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnMuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnMuteGlobalChats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnMuteGlobalChatsRequest, ::mruv::punishments::UnMuteGlobalChatsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::UnMuteGlobalChatsRequest* request, ::mruv::punishments::UnMuteGlobalChatsResponse* response) { return this->UnMuteGlobalChats(context, request, response); }));}
    void SetMessageAllocatorFor_UnMuteGlobalChats(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::UnMuteGlobalChatsRequest, ::mruv::punishments::UnMuteGlobalChatsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::UnMuteGlobalChatsRequest, ::mruv::punishments::UnMuteGlobalChatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnMuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnMuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnMuteGlobalChats(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnMuteGlobalChats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPlayerBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPlayerBans() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetPlayerBansRequest, ::mruv::punishments::GetPlayerBansResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::GetPlayerBansRequest* request, ::mruv::punishments::GetPlayerBansResponse* response) { return this->GetPlayerBans(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayerBans(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::GetPlayerBansRequest, ::mruv::punishments::GetPlayerBansResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetPlayerBansRequest, ::mruv::punishments::GetPlayerBansResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPlayerBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPlayerBans(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPlayerBans(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPlayerWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPlayerWarns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetPlayerWarnsRequest, ::mruv::punishments::GetPlayerWarnsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::GetPlayerWarnsRequest* request, ::mruv::punishments::GetPlayerWarnsResponse* response) { return this->GetPlayerWarns(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayerWarns(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::GetPlayerWarnsRequest, ::mruv::punishments::GetPlayerWarnsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetPlayerWarnsRequest, ::mruv::punishments::GetPlayerWarnsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPlayerWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPlayerWarns(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPlayerWarns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPlayerAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPlayerAdminJail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetPlayerAdminJailRequest, ::mruv::punishments::GetPlayerAdminJailResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::GetPlayerAdminJailRequest* request, ::mruv::punishments::GetPlayerAdminJailResponse* response) { return this->GetPlayerAdminJail(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayerAdminJail(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::GetPlayerAdminJailRequest, ::mruv::punishments::GetPlayerAdminJailResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetPlayerAdminJailRequest, ::mruv::punishments::GetPlayerAdminJailResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPlayerAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPlayerAdminJail(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPlayerAdminJail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetBanRequest, ::mruv::punishments::BanMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::GetBanRequest* request, ::mruv::punishments::BanMessage* response) { return this->GetBan(context, request, response); }));}
    void SetMessageAllocatorFor_GetBan(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::GetBanRequest, ::mruv::punishments::BanMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetBanRequest, ::mruv::punishments::BanMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBan(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetWarn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetWarnRequest, ::mruv::punishments::WarnMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::GetWarnRequest* request, ::mruv::punishments::WarnMessage* response) { return this->GetWarn(context, request, response); }));}
    void SetMessageAllocatorFor_GetWarn(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::GetWarnRequest, ::mruv::punishments::WarnMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetWarnRequest, ::mruv::punishments::WarnMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWarn(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWarn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetBlockRequest, ::mruv::punishments::BlockMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::GetBlockRequest* request, ::mruv::punishments::BlockMessage* response) { return this->GetBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlock(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::GetBlockRequest, ::mruv::punishments::BlockMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::GetBlockRequest, ::mruv::punishments::BlockMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IsPlayerBanned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_IsPlayerBanned() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::IsPlayerBannedRequest, ::mruv::punishments::IsPlayerBannedResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::IsPlayerBannedRequest* request, ::mruv::punishments::IsPlayerBannedResponse* response) { return this->IsPlayerBanned(context, request, response); }));}
    void SetMessageAllocatorFor_IsPlayerBanned(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::IsPlayerBannedRequest, ::mruv::punishments::IsPlayerBannedResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::IsPlayerBannedRequest, ::mruv::punishments::IsPlayerBannedResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_IsPlayerBanned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsPlayerBanned(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsPlayerBanned(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsPlayerBanned(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IsCharacterBlocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_IsCharacterBlocked() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::IsCharacterBlockedRequest, ::mruv::punishments::IsCharacterBlockedResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::IsCharacterBlockedRequest* request, ::mruv::punishments::IsCharacterBlockedResponse* response) { return this->IsCharacterBlocked(context, request, response); }));}
    void SetMessageAllocatorFor_IsCharacterBlocked(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::IsCharacterBlockedRequest, ::mruv::punishments::IsCharacterBlockedResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::IsCharacterBlockedRequest, ::mruv::punishments::IsCharacterBlockedResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_IsCharacterBlocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterBlocked(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsCharacterBlocked(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsCharacterBlocked(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IsCharacterJailed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_IsCharacterJailed() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::IsCharacterJailedRequest, ::mruv::punishments::IsCharacterJailedResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::IsCharacterJailedRequest* request, ::mruv::punishments::IsCharacterJailedResponse* response) { return this->IsCharacterJailed(context, request, response); }));}
    void SetMessageAllocatorFor_IsCharacterJailed(
        ::grpc::experimental::MessageAllocator< ::mruv::punishments::IsCharacterJailedRequest, ::mruv::punishments::IsCharacterJailedResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mruv::punishments::IsCharacterJailedRequest, ::mruv::punishments::IsCharacterJailedResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_IsCharacterJailed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterJailed(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsCharacterJailed(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsCharacterJailed(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchBans() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchBansRequest, ::mruv::punishments::BanMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchBansRequest* request) { return this->WatchBans(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::BanMessage>* WatchBans(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::BanMessage>* WatchBans(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchBlocksRequest, ::mruv::punishments::BlockMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchBlocksRequest* request) { return this->WatchBlocks(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::BlockMessage>* WatchBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::BlockMessage>* WatchBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchWarns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchWarnsRequest, ::mruv::punishments::WarnMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchWarnsRequest* request) { return this->WatchWarns(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::WarnMessage>* WatchWarns(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::WarnMessage>* WatchWarns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchAdminJails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchAdminJailsRequest, ::mruv::punishments::AdminJailMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchAdminJailsRequest* request) { return this->WatchAdminJails(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::AdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::AdminJailMessage>* WatchAdminJails(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::AdminJailMessage>* WatchAdminJails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchUnBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchUnBans() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchUnBansRequest, ::mruv::punishments::UnBanMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchUnBansRequest* request) { return this->WatchUnBans(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchUnBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::UnBanMessage>* WatchUnBans(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::UnBanMessage>* WatchUnBans(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchUnBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchUnBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchUnBlocksRequest, ::mruv::punishments::UnBlockMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchUnBlocksRequest* request) { return this->WatchUnBlocks(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchUnBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::UnBlockMessage>* WatchUnBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::UnBlockMessage>* WatchUnBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchUnWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchUnWarns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchUnWarnsRequest, ::mruv::punishments::UnWarnMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchUnWarnsRequest* request) { return this->WatchUnWarns(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchUnWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnWarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::UnWarnMessage>* WatchUnWarns(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::UnWarnMessage>* WatchUnWarns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchUnAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchUnAdminJails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchUnAdminJailsRequest, ::mruv::punishments::UnAdminJailMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchUnAdminJailsRequest* request) { return this->WatchUnAdminJails(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchUnAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnAdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::UnAdminJailMessage>* WatchUnAdminJails(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::UnAdminJailMessage>* WatchUnAdminJails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchPlayerPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchPlayerPunishments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchPlayerPunishmentsRequest, ::mruv::punishments::WatchPlayerPunishmentsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchPlayerPunishmentsRequest* request) { return this->WatchPlayerPunishments(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchPlayerPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::WatchPlayerPunishmentsResponse>* WatchPlayerPunishments(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::WatchPlayerPunishmentsResponse>* WatchPlayerPunishments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchPlayerAcquittals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchPlayerAcquittals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchPlayerAcquittalsRequest, ::mruv::punishments::WatchPlayerAcquittalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchPlayerAcquittalsRequest* request) { return this->WatchPlayerAcquittals(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchPlayerAcquittals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerAcquittals(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::WatchPlayerAcquittalsResponse>* WatchPlayerAcquittals(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::WatchPlayerAcquittalsResponse>* WatchPlayerAcquittals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchPunishments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mruv::punishments::WatchPunishmentsRequest, ::mruv::punishments::WatchPunishmentsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::punishments::WatchPunishmentsRequest* request) { return this->WatchPunishments(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::punishments::WatchPunishmentsResponse>* WatchPunishments(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::punishments::WatchPunishmentsResponse>* WatchPunishments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Ban<ExperimentalWithCallbackMethod_Block<ExperimentalWithCallbackMethod_Warn<ExperimentalWithCallbackMethod_AdminJail<ExperimentalWithCallbackMethod_MuteGlobalChats<ExperimentalWithCallbackMethod_UnBan<ExperimentalWithCallbackMethod_UnBlock<ExperimentalWithCallbackMethod_UnWarn<ExperimentalWithCallbackMethod_UnAdminJail<ExperimentalWithCallbackMethod_UnMuteGlobalChats<ExperimentalWithCallbackMethod_GetPlayerBans<ExperimentalWithCallbackMethod_GetPlayerWarns<ExperimentalWithCallbackMethod_GetPlayerAdminJail<ExperimentalWithCallbackMethod_GetBan<ExperimentalWithCallbackMethod_GetWarn<ExperimentalWithCallbackMethod_GetBlock<ExperimentalWithCallbackMethod_IsPlayerBanned<ExperimentalWithCallbackMethod_IsCharacterBlocked<ExperimentalWithCallbackMethod_IsCharacterJailed<ExperimentalWithCallbackMethod_WatchBans<ExperimentalWithCallbackMethod_WatchBlocks<ExperimentalWithCallbackMethod_WatchWarns<ExperimentalWithCallbackMethod_WatchAdminJails<ExperimentalWithCallbackMethod_WatchUnBans<ExperimentalWithCallbackMethod_WatchUnBlocks<ExperimentalWithCallbackMethod_WatchUnWarns<ExperimentalWithCallbackMethod_WatchUnAdminJails<ExperimentalWithCallbackMethod_WatchPlayerPunishments<ExperimentalWithCallbackMethod_WatchPlayerAcquittals<ExperimentalWithCallbackMethod_WatchPunishments<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Ban<ExperimentalWithCallbackMethod_Block<ExperimentalWithCallbackMethod_Warn<ExperimentalWithCallbackMethod_AdminJail<ExperimentalWithCallbackMethod_MuteGlobalChats<ExperimentalWithCallbackMethod_UnBan<ExperimentalWithCallbackMethod_UnBlock<ExperimentalWithCallbackMethod_UnWarn<ExperimentalWithCallbackMethod_UnAdminJail<ExperimentalWithCallbackMethod_UnMuteGlobalChats<ExperimentalWithCallbackMethod_GetPlayerBans<ExperimentalWithCallbackMethod_GetPlayerWarns<ExperimentalWithCallbackMethod_GetPlayerAdminJail<ExperimentalWithCallbackMethod_GetBan<ExperimentalWithCallbackMethod_GetWarn<ExperimentalWithCallbackMethod_GetBlock<ExperimentalWithCallbackMethod_IsPlayerBanned<ExperimentalWithCallbackMethod_IsCharacterBlocked<ExperimentalWithCallbackMethod_IsCharacterJailed<ExperimentalWithCallbackMethod_WatchBans<ExperimentalWithCallbackMethod_WatchBlocks<ExperimentalWithCallbackMethod_WatchWarns<ExperimentalWithCallbackMethod_WatchAdminJails<ExperimentalWithCallbackMethod_WatchUnBans<ExperimentalWithCallbackMethod_WatchUnBlocks<ExperimentalWithCallbackMethod_WatchUnWarns<ExperimentalWithCallbackMethod_WatchUnAdminJails<ExperimentalWithCallbackMethod_WatchPlayerPunishments<ExperimentalWithCallbackMethod_WatchPlayerAcquittals<ExperimentalWithCallbackMethod_WatchPunishments<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Ban : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ban() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Ban() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ban(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Block() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Warn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Warn() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Warn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Warn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AdminJail() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_AdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MuteGlobalChats() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnBan() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_UnBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnBlock() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UnBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnWarn() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_UnWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnAdminJail() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_UnAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnMuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnMuteGlobalChats() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_UnMuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnMuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayerBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayerBans() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetPlayerBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayerWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayerWarns() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetPlayerWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayerAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayerAdminJail() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetPlayerAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBan() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWarn() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlock() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsPlayerBanned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsPlayerBanned() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_IsPlayerBanned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsPlayerBanned(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsCharacterBlocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsCharacterBlocked() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_IsCharacterBlocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterBlocked(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsCharacterJailed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsCharacterJailed() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_IsCharacterJailed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterJailed(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchBans() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_WatchBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchBlocks() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_WatchBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchWarns() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_WatchWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchAdminJails() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_WatchAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::AdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchUnBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchUnBans() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_WatchUnBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchUnBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchUnBlocks() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_WatchUnBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchUnWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchUnWarns() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_WatchUnWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnWarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchUnAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchUnAdminJails() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_WatchUnAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnAdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchPlayerPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchPlayerPunishments() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_WatchPlayerPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchPlayerAcquittals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchPlayerAcquittals() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_WatchPlayerAcquittals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerAcquittals(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchPunishments() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_WatchPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ban : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ban() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Ban() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ban(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Block() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Warn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Warn() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Warn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Warn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWarn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AdminJail() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_AdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAdminJail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MuteGlobalChats() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMuteGlobalChats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnBan() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_UnBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnBan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnBlock() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UnBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnWarn() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_UnWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnWarn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnAdminJail() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_UnAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnAdminJail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnMuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnMuteGlobalChats() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_UnMuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnMuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnMuteGlobalChats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayerBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayerBans() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetPlayerBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerBans(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayerWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayerWarns() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetPlayerWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerWarns(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayerAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayerAdminJail() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetPlayerAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerAdminJail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBan() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWarn() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWarn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlock() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsPlayerBanned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsPlayerBanned() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_IsPlayerBanned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsPlayerBanned(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsPlayerBanned(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsCharacterBlocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsCharacterBlocked() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_IsCharacterBlocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterBlocked(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsCharacterBlocked(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsCharacterJailed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsCharacterJailed() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_IsCharacterJailed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterJailed(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsCharacterJailed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchBans() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_WatchBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBans(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(19, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchBlocks() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_WatchBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(20, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchWarns() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_WatchWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchWarns(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(21, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchAdminJails() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_WatchAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::AdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchAdminJails(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchUnBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchUnBans() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_WatchUnBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnBans(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(23, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchUnBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchUnBlocks() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_WatchUnBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnBlocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchUnWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchUnWarns() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_WatchUnWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnWarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnWarns(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchUnAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchUnAdminJails() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_WatchUnAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnAdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchUnAdminJails(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(26, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchPlayerPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchPlayerPunishments() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_WatchPlayerPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchPlayerPunishments(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(27, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchPlayerAcquittals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchPlayerAcquittals() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_WatchPlayerAcquittals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerAcquittals(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchPlayerAcquittals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(28, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchPunishments() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_WatchPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchPunishments(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(29, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Ban : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Ban() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ban(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Ban() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ban(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ban(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ban(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Block() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Block(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Block(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Block(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Warn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Warn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Warn(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Warn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Warn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Warn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Warn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AdminJail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AdminJail(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AdminJail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AdminJail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MuteGlobalChats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MuteGlobalChats(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MuteGlobalChats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MuteGlobalChats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnBan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnBan(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnBan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnBan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnWarn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnWarn(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnWarn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnWarn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnAdminJail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnAdminJail(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnAdminJail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnAdminJail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnMuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnMuteGlobalChats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnMuteGlobalChats(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnMuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnMuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnMuteGlobalChats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnMuteGlobalChats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPlayerBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPlayerBans() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayerBans(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPlayerBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPlayerBans(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPlayerBans(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPlayerWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPlayerWarns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayerWarns(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPlayerWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPlayerWarns(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPlayerWarns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPlayerAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPlayerAdminJail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayerAdminJail(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPlayerAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPlayerAdminJail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPlayerAdminJail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBan(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWarn() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWarn(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWarn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWarn(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IsPlayerBanned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_IsPlayerBanned() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsPlayerBanned(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_IsPlayerBanned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsPlayerBanned(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsPlayerBanned(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsPlayerBanned(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IsCharacterBlocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_IsCharacterBlocked() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsCharacterBlocked(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_IsCharacterBlocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterBlocked(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsCharacterBlocked(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsCharacterBlocked(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IsCharacterJailed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_IsCharacterJailed() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsCharacterJailed(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_IsCharacterJailed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsCharacterJailed(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsCharacterJailed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsCharacterJailed(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchBans() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchBans(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBans(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBans(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchBlocks(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchWarns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchWarns(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchWarns(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchWarns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchAdminJails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchAdminJails(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::AdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchAdminJails(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchAdminJails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchUnBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchUnBans() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchUnBans(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchUnBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnBans(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnBans(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchUnBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchUnBlocks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchUnBlocks(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchUnBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnBlocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnBlocks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchUnWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchUnWarns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchUnWarns(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchUnWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnWarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnWarns(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnWarns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchUnAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchUnAdminJails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchUnAdminJails(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchUnAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchUnAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnAdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnAdminJails(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchUnAdminJails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchPlayerPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchPlayerPunishments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchPlayerPunishments(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchPlayerPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchPlayerPunishments(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchPlayerPunishments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchPlayerAcquittals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchPlayerAcquittals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchPlayerAcquittals(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchPlayerAcquittals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPlayerAcquittals(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchPlayerAcquittals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchPlayerAcquittals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchPunishments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchPunishments(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchPunishments(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchPunishments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ban : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ban() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::BanRequest, ::mruv::punishments::BanResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::BanRequest, ::mruv::punishments::BanResponse>* streamer) {
                       return this->StreamedBan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ban() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ban(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BanRequest* /*request*/, ::mruv::punishments::BanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::BanRequest,::mruv::punishments::BanResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Block : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Block() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::BlockRequest, ::mruv::punishments::BlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::BlockRequest, ::mruv::punishments::BlockResponse>* streamer) {
                       return this->StreamedBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Block() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Block(::grpc::ServerContext* /*context*/, const ::mruv::punishments::BlockRequest* /*request*/, ::mruv::punishments::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::BlockRequest,::mruv::punishments::BlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Warn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Warn() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::WarnRequest, ::mruv::punishments::WarnResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::WarnRequest, ::mruv::punishments::WarnResponse>* streamer) {
                       return this->StreamedWarn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Warn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Warn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WarnRequest* /*request*/, ::mruv::punishments::WarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWarn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::WarnRequest,::mruv::punishments::WarnResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AdminJail() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::AdminJailRequest, ::mruv::punishments::AdminJailResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::AdminJailRequest, ::mruv::punishments::AdminJailResponse>* streamer) {
                       return this->StreamedAdminJail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::AdminJailRequest* /*request*/, ::mruv::punishments::AdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAdminJail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::AdminJailRequest,::mruv::punishments::AdminJailResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MuteGlobalChats() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::MuteGlobalChatsRequest, ::mruv::punishments::MuteGlobalChatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::MuteGlobalChatsRequest, ::mruv::punishments::MuteGlobalChatsResponse>* streamer) {
                       return this->StreamedMuteGlobalChats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::MuteGlobalChatsRequest* /*request*/, ::mruv::punishments::MuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMuteGlobalChats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::MuteGlobalChatsRequest,::mruv::punishments::MuteGlobalChatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnBan() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::UnBanRequest, ::mruv::punishments::UnBanResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::UnBanRequest, ::mruv::punishments::UnBanResponse>* streamer) {
                       return this->StreamedUnBan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBanRequest* /*request*/, ::mruv::punishments::UnBanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnBan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::UnBanRequest,::mruv::punishments::UnBanResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnBlock() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::UnBlockRequest, ::mruv::punishments::UnBlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::UnBlockRequest, ::mruv::punishments::UnBlockResponse>* streamer) {
                       return this->StreamedUnBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnBlockRequest* /*request*/, ::mruv::punishments::UnBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::UnBlockRequest,::mruv::punishments::UnBlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnWarn() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::UnWarnRequest, ::mruv::punishments::UnWarnResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::UnWarnRequest, ::mruv::punishments::UnWarnResponse>* streamer) {
                       return this->StreamedUnWarn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnWarnRequest* /*request*/, ::mruv::punishments::UnWarnResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnWarn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::UnWarnRequest,::mruv::punishments::UnWarnResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnAdminJail() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::UnAdminJailRequest, ::mruv::punishments::UnAdminJailResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::UnAdminJailRequest, ::mruv::punishments::UnAdminJailResponse>* streamer) {
                       return this->StreamedUnAdminJail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnAdminJailRequest* /*request*/, ::mruv::punishments::UnAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnAdminJail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::UnAdminJailRequest,::mruv::punishments::UnAdminJailResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnMuteGlobalChats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnMuteGlobalChats() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::UnMuteGlobalChatsRequest, ::mruv::punishments::UnMuteGlobalChatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::UnMuteGlobalChatsRequest, ::mruv::punishments::UnMuteGlobalChatsResponse>* streamer) {
                       return this->StreamedUnMuteGlobalChats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnMuteGlobalChats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnMuteGlobalChats(::grpc::ServerContext* /*context*/, const ::mruv::punishments::UnMuteGlobalChatsRequest* /*request*/, ::mruv::punishments::UnMuteGlobalChatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnMuteGlobalChats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::UnMuteGlobalChatsRequest,::mruv::punishments::UnMuteGlobalChatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayerBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayerBans() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::GetPlayerBansRequest, ::mruv::punishments::GetPlayerBansResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::GetPlayerBansRequest, ::mruv::punishments::GetPlayerBansResponse>* streamer) {
                       return this->StreamedGetPlayerBans(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayerBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayerBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerBansRequest* /*request*/, ::mruv::punishments::GetPlayerBansResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayerBans(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::GetPlayerBansRequest,::mruv::punishments::GetPlayerBansResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayerWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayerWarns() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::GetPlayerWarnsRequest, ::mruv::punishments::GetPlayerWarnsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::GetPlayerWarnsRequest, ::mruv::punishments::GetPlayerWarnsResponse>* streamer) {
                       return this->StreamedGetPlayerWarns(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayerWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayerWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerWarnsRequest* /*request*/, ::mruv::punishments::GetPlayerWarnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayerWarns(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::GetPlayerWarnsRequest,::mruv::punishments::GetPlayerWarnsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayerAdminJail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayerAdminJail() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::GetPlayerAdminJailRequest, ::mruv::punishments::GetPlayerAdminJailResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::GetPlayerAdminJailRequest, ::mruv::punishments::GetPlayerAdminJailResponse>* streamer) {
                       return this->StreamedGetPlayerAdminJail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayerAdminJail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayerAdminJail(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetPlayerAdminJailRequest* /*request*/, ::mruv::punishments::GetPlayerAdminJailResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayerAdminJail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::GetPlayerAdminJailRequest,::mruv::punishments::GetPlayerAdminJailResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBan() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::GetBanRequest, ::mruv::punishments::BanMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::GetBanRequest, ::mruv::punishments::BanMessage>* streamer) {
                       return this->StreamedGetBan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBan(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBanRequest* /*request*/, ::mruv::punishments::BanMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::GetBanRequest,::mruv::punishments::BanMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWarn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWarn() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::GetWarnRequest, ::mruv::punishments::WarnMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::GetWarnRequest, ::mruv::punishments::WarnMessage>* streamer) {
                       return this->StreamedGetWarn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWarn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWarn(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetWarnRequest* /*request*/, ::mruv::punishments::WarnMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWarn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::GetWarnRequest,::mruv::punishments::WarnMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlock() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::GetBlockRequest, ::mruv::punishments::BlockMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::GetBlockRequest, ::mruv::punishments::BlockMessage>* streamer) {
                       return this->StreamedGetBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* /*context*/, const ::mruv::punishments::GetBlockRequest* /*request*/, ::mruv::punishments::BlockMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::GetBlockRequest,::mruv::punishments::BlockMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsPlayerBanned : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsPlayerBanned() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::IsPlayerBannedRequest, ::mruv::punishments::IsPlayerBannedResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::IsPlayerBannedRequest, ::mruv::punishments::IsPlayerBannedResponse>* streamer) {
                       return this->StreamedIsPlayerBanned(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsPlayerBanned() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsPlayerBanned(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsPlayerBannedRequest* /*request*/, ::mruv::punishments::IsPlayerBannedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsPlayerBanned(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::IsPlayerBannedRequest,::mruv::punishments::IsPlayerBannedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsCharacterBlocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsCharacterBlocked() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::IsCharacterBlockedRequest, ::mruv::punishments::IsCharacterBlockedResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::IsCharacterBlockedRequest, ::mruv::punishments::IsCharacterBlockedResponse>* streamer) {
                       return this->StreamedIsCharacterBlocked(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsCharacterBlocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsCharacterBlocked(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterBlockedRequest* /*request*/, ::mruv::punishments::IsCharacterBlockedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsCharacterBlocked(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::IsCharacterBlockedRequest,::mruv::punishments::IsCharacterBlockedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsCharacterJailed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsCharacterJailed() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::punishments::IsCharacterJailedRequest, ::mruv::punishments::IsCharacterJailedResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mruv::punishments::IsCharacterJailedRequest, ::mruv::punishments::IsCharacterJailedResponse>* streamer) {
                       return this->StreamedIsCharacterJailed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsCharacterJailed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsCharacterJailed(::grpc::ServerContext* /*context*/, const ::mruv::punishments::IsCharacterJailedRequest* /*request*/, ::mruv::punishments::IsCharacterJailedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsCharacterJailed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::punishments::IsCharacterJailedRequest,::mruv::punishments::IsCharacterJailedResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Ban<WithStreamedUnaryMethod_Block<WithStreamedUnaryMethod_Warn<WithStreamedUnaryMethod_AdminJail<WithStreamedUnaryMethod_MuteGlobalChats<WithStreamedUnaryMethod_UnBan<WithStreamedUnaryMethod_UnBlock<WithStreamedUnaryMethod_UnWarn<WithStreamedUnaryMethod_UnAdminJail<WithStreamedUnaryMethod_UnMuteGlobalChats<WithStreamedUnaryMethod_GetPlayerBans<WithStreamedUnaryMethod_GetPlayerWarns<WithStreamedUnaryMethod_GetPlayerAdminJail<WithStreamedUnaryMethod_GetBan<WithStreamedUnaryMethod_GetWarn<WithStreamedUnaryMethod_GetBlock<WithStreamedUnaryMethod_IsPlayerBanned<WithStreamedUnaryMethod_IsCharacterBlocked<WithStreamedUnaryMethod_IsCharacterJailed<Service > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchBans() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchBansRequest, ::mruv::punishments::BanMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchBansRequest, ::mruv::punishments::BanMessage>* streamer) {
                       return this->StreamedWatchBans(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchBans(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchBansRequest,::mruv::punishments::BanMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchBlocks() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchBlocksRequest, ::mruv::punishments::BlockMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchBlocksRequest, ::mruv::punishments::BlockMessage>* streamer) {
                       return this->StreamedWatchBlocks(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::BlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchBlocks(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchBlocksRequest,::mruv::punishments::BlockMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchWarns() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchWarnsRequest, ::mruv::punishments::WarnMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchWarnsRequest, ::mruv::punishments::WarnMessage>* streamer) {
                       return this->StreamedWatchWarns(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchWarns(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchWarnsRequest,::mruv::punishments::WarnMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchAdminJails() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchAdminJailsRequest, ::mruv::punishments::AdminJailMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchAdminJailsRequest, ::mruv::punishments::AdminJailMessage>* streamer) {
                       return this->StreamedWatchAdminJails(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::AdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchAdminJails(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchAdminJailsRequest,::mruv::punishments::AdminJailMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchUnBans : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchUnBans() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchUnBansRequest, ::mruv::punishments::UnBanMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchUnBansRequest, ::mruv::punishments::UnBanMessage>* streamer) {
                       return this->StreamedWatchUnBans(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchUnBans() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchUnBans(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBansRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBanMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchUnBans(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchUnBansRequest,::mruv::punishments::UnBanMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchUnBlocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchUnBlocks() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchUnBlocksRequest, ::mruv::punishments::UnBlockMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchUnBlocksRequest, ::mruv::punishments::UnBlockMessage>* streamer) {
                       return this->StreamedWatchUnBlocks(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchUnBlocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchUnBlocks(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnBlocksRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnBlockMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchUnBlocks(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchUnBlocksRequest,::mruv::punishments::UnBlockMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchUnWarns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchUnWarns() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchUnWarnsRequest, ::mruv::punishments::UnWarnMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchUnWarnsRequest, ::mruv::punishments::UnWarnMessage>* streamer) {
                       return this->StreamedWatchUnWarns(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchUnWarns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchUnWarns(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnWarnsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnWarnMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchUnWarns(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchUnWarnsRequest,::mruv::punishments::UnWarnMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchUnAdminJails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchUnAdminJails() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchUnAdminJailsRequest, ::mruv::punishments::UnAdminJailMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchUnAdminJailsRequest, ::mruv::punishments::UnAdminJailMessage>* streamer) {
                       return this->StreamedWatchUnAdminJails(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchUnAdminJails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchUnAdminJails(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchUnAdminJailsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::UnAdminJailMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchUnAdminJails(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchUnAdminJailsRequest,::mruv::punishments::UnAdminJailMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchPlayerPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchPlayerPunishments() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchPlayerPunishmentsRequest, ::mruv::punishments::WatchPlayerPunishmentsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchPlayerPunishmentsRequest, ::mruv::punishments::WatchPlayerPunishmentsResponse>* streamer) {
                       return this->StreamedWatchPlayerPunishments(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchPlayerPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchPlayerPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchPlayerPunishments(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchPlayerPunishmentsRequest,::mruv::punishments::WatchPlayerPunishmentsResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchPlayerAcquittals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchPlayerAcquittals() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchPlayerAcquittalsRequest, ::mruv::punishments::WatchPlayerAcquittalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchPlayerAcquittalsRequest, ::mruv::punishments::WatchPlayerAcquittalsResponse>* streamer) {
                       return this->StreamedWatchPlayerAcquittals(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchPlayerAcquittals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchPlayerAcquittals(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPlayerAcquittalsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPlayerAcquittalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchPlayerAcquittals(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchPlayerAcquittalsRequest,::mruv::punishments::WatchPlayerAcquittalsResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchPunishments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchPunishments() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::punishments::WatchPunishmentsRequest, ::mruv::punishments::WatchPunishmentsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mruv::punishments::WatchPunishmentsRequest, ::mruv::punishments::WatchPunishmentsResponse>* streamer) {
                       return this->StreamedWatchPunishments(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchPunishments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchPunishments(::grpc::ServerContext* /*context*/, const ::mruv::punishments::WatchPunishmentsRequest* /*request*/, ::grpc::ServerWriter< ::mruv::punishments::WatchPunishmentsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchPunishments(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::punishments::WatchPunishmentsRequest,::mruv::punishments::WatchPunishmentsResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_WatchBans<WithSplitStreamingMethod_WatchBlocks<WithSplitStreamingMethod_WatchWarns<WithSplitStreamingMethod_WatchAdminJails<WithSplitStreamingMethod_WatchUnBans<WithSplitStreamingMethod_WatchUnBlocks<WithSplitStreamingMethod_WatchUnWarns<WithSplitStreamingMethod_WatchUnAdminJails<WithSplitStreamingMethod_WatchPlayerPunishments<WithSplitStreamingMethod_WatchPlayerAcquittals<WithSplitStreamingMethod_WatchPunishments<Service > > > > > > > > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Ban<WithStreamedUnaryMethod_Block<WithStreamedUnaryMethod_Warn<WithStreamedUnaryMethod_AdminJail<WithStreamedUnaryMethod_MuteGlobalChats<WithStreamedUnaryMethod_UnBan<WithStreamedUnaryMethod_UnBlock<WithStreamedUnaryMethod_UnWarn<WithStreamedUnaryMethod_UnAdminJail<WithStreamedUnaryMethod_UnMuteGlobalChats<WithStreamedUnaryMethod_GetPlayerBans<WithStreamedUnaryMethod_GetPlayerWarns<WithStreamedUnaryMethod_GetPlayerAdminJail<WithStreamedUnaryMethod_GetBan<WithStreamedUnaryMethod_GetWarn<WithStreamedUnaryMethod_GetBlock<WithStreamedUnaryMethod_IsPlayerBanned<WithStreamedUnaryMethod_IsCharacterBlocked<WithStreamedUnaryMethod_IsCharacterJailed<WithSplitStreamingMethod_WatchBans<WithSplitStreamingMethod_WatchBlocks<WithSplitStreamingMethod_WatchWarns<WithSplitStreamingMethod_WatchAdminJails<WithSplitStreamingMethod_WatchUnBans<WithSplitStreamingMethod_WatchUnBlocks<WithSplitStreamingMethod_WatchUnWarns<WithSplitStreamingMethod_WatchUnAdminJails<WithSplitStreamingMethod_WatchPlayerPunishments<WithSplitStreamingMethod_WatchPlayerAcquittals<WithSplitStreamingMethod_WatchPunishments<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace punishments
}  // namespace mruv


#endif  // GRPC_punishments_2fpunishments_2eproto__INCLUDED
