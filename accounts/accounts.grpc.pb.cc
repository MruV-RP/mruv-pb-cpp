// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: accounts/accounts.proto

#include "accounts/accounts.pb.h"
#include "accounts/accounts.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace mruv {

static const char* MruVAccountsService_method_names[] = {
  "/mruv.MruVAccountsService/RegisterAccount",
  "/mruv.MruVAccountsService/LogIn",
  "/mruv.MruVAccountsService/IsAccountExist",
  "/mruv.MruVAccountsService/GetAccount",
  "/mruv.MruVAccountsService/GetAccountCharacters",
};

std::unique_ptr< MruVAccountsService::Stub> MruVAccountsService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< MruVAccountsService::Stub> stub(new MruVAccountsService::Stub(channel));
  return stub;
}

MruVAccountsService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_RegisterAccount_(MruVAccountsService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_LogIn_(MruVAccountsService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_IsAccountExist_(MruVAccountsService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAccount_(MruVAccountsService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAccountCharacters_(MruVAccountsService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status MruVAccountsService::Stub::RegisterAccount(::grpc::ClientContext* context, const ::mruv::RegisterAccountRequest& request, ::mruv::RegisterAccountResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_RegisterAccount_, context, request, response);
}

void MruVAccountsService::Stub::experimental_async::RegisterAccount(::grpc::ClientContext* context, const ::mruv::RegisterAccountRequest* request, ::mruv::RegisterAccountResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_RegisterAccount_, context, request, response, std::move(f));
}

void MruVAccountsService::Stub::experimental_async::RegisterAccount(::grpc::ClientContext* context, const ::mruv::RegisterAccountRequest* request, ::mruv::RegisterAccountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_RegisterAccount_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::mruv::RegisterAccountResponse>* MruVAccountsService::Stub::PrepareAsyncRegisterAccountRaw(::grpc::ClientContext* context, const ::mruv::RegisterAccountRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::mruv::RegisterAccountResponse>::Create(channel_.get(), cq, rpcmethod_RegisterAccount_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::mruv::RegisterAccountResponse>* MruVAccountsService::Stub::AsyncRegisterAccountRaw(::grpc::ClientContext* context, const ::mruv::RegisterAccountRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRegisterAccountRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status MruVAccountsService::Stub::LogIn(::grpc::ClientContext* context, const ::mruv::LogInRequest& request, ::mruv::LogInResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_LogIn_, context, request, response);
}

void MruVAccountsService::Stub::experimental_async::LogIn(::grpc::ClientContext* context, const ::mruv::LogInRequest* request, ::mruv::LogInResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_LogIn_, context, request, response, std::move(f));
}

void MruVAccountsService::Stub::experimental_async::LogIn(::grpc::ClientContext* context, const ::mruv::LogInRequest* request, ::mruv::LogInResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_LogIn_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::mruv::LogInResponse>* MruVAccountsService::Stub::PrepareAsyncLogInRaw(::grpc::ClientContext* context, const ::mruv::LogInRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::mruv::LogInResponse>::Create(channel_.get(), cq, rpcmethod_LogIn_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::mruv::LogInResponse>* MruVAccountsService::Stub::AsyncLogInRaw(::grpc::ClientContext* context, const ::mruv::LogInRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncLogInRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status MruVAccountsService::Stub::IsAccountExist(::grpc::ClientContext* context, const ::mruv::IsAccountExistRequest& request, ::mruv::IsAccountExistResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_IsAccountExist_, context, request, response);
}

void MruVAccountsService::Stub::experimental_async::IsAccountExist(::grpc::ClientContext* context, const ::mruv::IsAccountExistRequest* request, ::mruv::IsAccountExistResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_IsAccountExist_, context, request, response, std::move(f));
}

void MruVAccountsService::Stub::experimental_async::IsAccountExist(::grpc::ClientContext* context, const ::mruv::IsAccountExistRequest* request, ::mruv::IsAccountExistResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_IsAccountExist_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::mruv::IsAccountExistResponse>* MruVAccountsService::Stub::PrepareAsyncIsAccountExistRaw(::grpc::ClientContext* context, const ::mruv::IsAccountExistRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::mruv::IsAccountExistResponse>::Create(channel_.get(), cq, rpcmethod_IsAccountExist_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::mruv::IsAccountExistResponse>* MruVAccountsService::Stub::AsyncIsAccountExistRaw(::grpc::ClientContext* context, const ::mruv::IsAccountExistRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncIsAccountExistRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status MruVAccountsService::Stub::GetAccount(::grpc::ClientContext* context, const ::mruv::GetAccountRequest& request, ::mruv::GetAccountResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAccount_, context, request, response);
}

void MruVAccountsService::Stub::experimental_async::GetAccount(::grpc::ClientContext* context, const ::mruv::GetAccountRequest* request, ::mruv::GetAccountResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAccount_, context, request, response, std::move(f));
}

void MruVAccountsService::Stub::experimental_async::GetAccount(::grpc::ClientContext* context, const ::mruv::GetAccountRequest* request, ::mruv::GetAccountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAccount_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::mruv::GetAccountResponse>* MruVAccountsService::Stub::PrepareAsyncGetAccountRaw(::grpc::ClientContext* context, const ::mruv::GetAccountRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::mruv::GetAccountResponse>::Create(channel_.get(), cq, rpcmethod_GetAccount_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::mruv::GetAccountResponse>* MruVAccountsService::Stub::AsyncGetAccountRaw(::grpc::ClientContext* context, const ::mruv::GetAccountRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetAccountRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status MruVAccountsService::Stub::GetAccountCharacters(::grpc::ClientContext* context, const ::mruv::GetAccountCharactersRequest& request, ::mruv::GetAccountCharactersResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAccountCharacters_, context, request, response);
}

void MruVAccountsService::Stub::experimental_async::GetAccountCharacters(::grpc::ClientContext* context, const ::mruv::GetAccountCharactersRequest* request, ::mruv::GetAccountCharactersResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAccountCharacters_, context, request, response, std::move(f));
}

void MruVAccountsService::Stub::experimental_async::GetAccountCharacters(::grpc::ClientContext* context, const ::mruv::GetAccountCharactersRequest* request, ::mruv::GetAccountCharactersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAccountCharacters_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::mruv::GetAccountCharactersResponse>* MruVAccountsService::Stub::PrepareAsyncGetAccountCharactersRaw(::grpc::ClientContext* context, const ::mruv::GetAccountCharactersRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::mruv::GetAccountCharactersResponse>::Create(channel_.get(), cq, rpcmethod_GetAccountCharacters_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::mruv::GetAccountCharactersResponse>* MruVAccountsService::Stub::AsyncGetAccountCharactersRaw(::grpc::ClientContext* context, const ::mruv::GetAccountCharactersRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetAccountCharactersRaw(context, request, cq);
  result->StartCall();
  return result;
}

MruVAccountsService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MruVAccountsService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MruVAccountsService::Service, ::mruv::RegisterAccountRequest, ::mruv::RegisterAccountResponse>(
          [](MruVAccountsService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::mruv::RegisterAccountRequest* req,
             ::mruv::RegisterAccountResponse* resp) {
               return service->RegisterAccount(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MruVAccountsService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MruVAccountsService::Service, ::mruv::LogInRequest, ::mruv::LogInResponse>(
          [](MruVAccountsService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::mruv::LogInRequest* req,
             ::mruv::LogInResponse* resp) {
               return service->LogIn(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MruVAccountsService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MruVAccountsService::Service, ::mruv::IsAccountExistRequest, ::mruv::IsAccountExistResponse>(
          [](MruVAccountsService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::mruv::IsAccountExistRequest* req,
             ::mruv::IsAccountExistResponse* resp) {
               return service->IsAccountExist(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MruVAccountsService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MruVAccountsService::Service, ::mruv::GetAccountRequest, ::mruv::GetAccountResponse>(
          [](MruVAccountsService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::mruv::GetAccountRequest* req,
             ::mruv::GetAccountResponse* resp) {
               return service->GetAccount(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MruVAccountsService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MruVAccountsService::Service, ::mruv::GetAccountCharactersRequest, ::mruv::GetAccountCharactersResponse>(
          [](MruVAccountsService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::mruv::GetAccountCharactersRequest* req,
             ::mruv::GetAccountCharactersResponse* resp) {
               return service->GetAccountCharacters(ctx, req, resp);
             }, this)));
}

MruVAccountsService::Service::~Service() {
}

::grpc::Status MruVAccountsService::Service::RegisterAccount(::grpc::ServerContext* context, const ::mruv::RegisterAccountRequest* request, ::mruv::RegisterAccountResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status MruVAccountsService::Service::LogIn(::grpc::ServerContext* context, const ::mruv::LogInRequest* request, ::mruv::LogInResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status MruVAccountsService::Service::IsAccountExist(::grpc::ServerContext* context, const ::mruv::IsAccountExistRequest* request, ::mruv::IsAccountExistResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status MruVAccountsService::Service::GetAccount(::grpc::ServerContext* context, const ::mruv::GetAccountRequest* request, ::mruv::GetAccountResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status MruVAccountsService::Service::GetAccountCharacters(::grpc::ServerContext* context, const ::mruv::GetAccountCharactersRequest* request, ::mruv::GetAccountCharactersResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace mruv

