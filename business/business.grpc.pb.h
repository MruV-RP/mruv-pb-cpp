// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: business/business.proto
#ifndef GRPC_business_2fbusiness_2eproto__INCLUDED
#define GRPC_business_2fbusiness_2eproto__INCLUDED

#include "business/business.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mruv {
namespace business {

// The MruV business service provides procedures for managing businesses.
// Business can be owned by a player or organisation. Every business have it's own group and products to sell.
// Business can have rights to an estates.
// Every business has its own type and depends on it, business provides different services.
class MruVBusinessService final {
 public:
  static constexpr char const* service_full_name() {
    return "mruv.business.MruVBusinessService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Create a business.
    virtual ::grpc::Status CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::mruv::business::CreateBusinessResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::CreateBusinessResponse>> AsyncCreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::CreateBusinessResponse>>(AsyncCreateBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::CreateBusinessResponse>> PrepareAsyncCreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::CreateBusinessResponse>>(PrepareAsyncCreateBusinessRaw(context, request, cq));
    }
    // Get a business.
    virtual ::grpc::Status GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::mruv::business::Business* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>> AsyncGetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>>(AsyncGetBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>> PrepareAsyncGetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>>(PrepareAsyncGetBusinessRaw(context, request, cq));
    }
    // Update a business.
    virtual ::grpc::Status UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::mruv::business::Business* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>> AsyncUpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>>(AsyncUpdateBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>> PrepareAsyncUpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>>(PrepareAsyncUpdateBusinessRaw(context, request, cq));
    }
    // Delete a business.
    virtual ::grpc::Status DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::mruv::business::DeleteBusinessResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::DeleteBusinessResponse>> AsyncDeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::DeleteBusinessResponse>>(AsyncDeleteBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::DeleteBusinessResponse>> PrepareAsyncDeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::DeleteBusinessResponse>>(PrepareAsyncDeleteBusinessRaw(context, request, cq));
    }
    // Assign a business owner.
    virtual ::grpc::Status AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::mruv::business::AssignOwnerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignOwnerResponse>> AsyncAssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignOwnerResponse>>(AsyncAssignOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignOwnerResponse>> PrepareAsyncAssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignOwnerResponse>>(PrepareAsyncAssignOwnerRaw(context, request, cq));
    }
    // Assign an estate to a business.
    virtual ::grpc::Status AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::mruv::business::AssignEstateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignEstateResponse>> AsyncAssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignEstateResponse>>(AsyncAssignEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignEstateResponse>> PrepareAsyncAssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignEstateResponse>>(PrepareAsyncAssignEstateRaw(context, request, cq));
    }
    //
    virtual ::grpc::Status UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::mruv::business::UnassignEstateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::UnassignEstateResponse>> AsyncUnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::UnassignEstateResponse>>(AsyncUnassignEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::UnassignEstateResponse>> PrepareAsyncUnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::UnassignEstateResponse>>(PrepareAsyncUnassignEstateRaw(context, request, cq));
    }
    // Buy a business.
    virtual ::grpc::Status BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::mruv::business::BuyBusinessResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::BuyBusinessResponse>> AsyncBuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::BuyBusinessResponse>>(AsyncBuyBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::BuyBusinessResponse>> PrepareAsyncBuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::BuyBusinessResponse>>(PrepareAsyncBuyBusinessRaw(context, request, cq));
    }
    // Subscribe to business events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::business::WatchBusinessResponse>> WatchBusiness(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::business::WatchBusinessResponse>>(WatchBusinessRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessResponse>> AsyncWatchBusiness(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessResponse>>(AsyncWatchBusinessRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessResponse>> PrepareAsyncWatchBusiness(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessResponse>>(PrepareAsyncWatchBusinessRaw(context, request, cq));
    }
    // Subscribe to all businesses events.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::business::WatchBusinessesResponse>> WatchBusinesses(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mruv::business::WatchBusinessesResponse>>(WatchBusinessesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessesResponse>> AsyncWatchBusinesses(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessesResponse>>(AsyncWatchBusinessesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessesResponse>> PrepareAsyncWatchBusinesses(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessesResponse>>(PrepareAsyncWatchBusinessesRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Create a business.
      virtual void CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::CreateBusinessResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a business.
      virtual void GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Update a business.
      virtual void UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a business.
      virtual void DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::DeleteBusinessResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Assign a business owner.
      virtual void AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AssignOwner(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignOwnerResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AssignOwner(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AssignOwner(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Assign an estate to a business.
      virtual void AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AssignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AssignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AssignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      virtual void UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnassignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::UnassignEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnassignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnassignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Buy a business.
      virtual void BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BuyBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::BuyBusinessResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BuyBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BuyBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Subscribe to business events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchBusiness(::grpc::ClientContext* context, ::mruv::business::WatchBusinessRequest* request, ::grpc::ClientReadReactor< ::mruv::business::WatchBusinessResponse>* reactor) = 0;
      #else
      virtual void WatchBusiness(::grpc::ClientContext* context, ::mruv::business::WatchBusinessRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::business::WatchBusinessResponse>* reactor) = 0;
      #endif
      // Subscribe to all businesses events.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WatchBusinesses(::grpc::ClientContext* context, ::mruv::business::WatchBusinessesRequest* request, ::grpc::ClientReadReactor< ::mruv::business::WatchBusinessesResponse>* reactor) = 0;
      #else
      virtual void WatchBusinesses(::grpc::ClientContext* context, ::mruv::business::WatchBusinessesRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::business::WatchBusinessesResponse>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::CreateBusinessResponse>* AsyncCreateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::CreateBusinessResponse>* PrepareAsyncCreateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>* AsyncGetBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>* PrepareAsyncGetBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>* AsyncUpdateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::Business>* PrepareAsyncUpdateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::DeleteBusinessResponse>* AsyncDeleteBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::DeleteBusinessResponse>* PrepareAsyncDeleteBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignOwnerResponse>* AsyncAssignOwnerRaw(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignOwnerResponse>* PrepareAsyncAssignOwnerRaw(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignEstateResponse>* AsyncAssignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::AssignEstateResponse>* PrepareAsyncAssignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::UnassignEstateResponse>* AsyncUnassignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::UnassignEstateResponse>* PrepareAsyncUnassignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::BuyBusinessResponse>* AsyncBuyBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::business::BuyBusinessResponse>* PrepareAsyncBuyBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::business::WatchBusinessResponse>* WatchBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessResponse>* AsyncWatchBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessResponse>* PrepareAsyncWatchBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mruv::business::WatchBusinessesResponse>* WatchBusinessesRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessesResponse>* AsyncWatchBusinessesRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mruv::business::WatchBusinessesResponse>* PrepareAsyncWatchBusinessesRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::mruv::business::CreateBusinessResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::CreateBusinessResponse>> AsyncCreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::CreateBusinessResponse>>(AsyncCreateBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::CreateBusinessResponse>> PrepareAsyncCreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::CreateBusinessResponse>>(PrepareAsyncCreateBusinessRaw(context, request, cq));
    }
    ::grpc::Status GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::mruv::business::Business* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>> AsyncGetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>>(AsyncGetBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>> PrepareAsyncGetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>>(PrepareAsyncGetBusinessRaw(context, request, cq));
    }
    ::grpc::Status UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::mruv::business::Business* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>> AsyncUpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>>(AsyncUpdateBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>> PrepareAsyncUpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>>(PrepareAsyncUpdateBusinessRaw(context, request, cq));
    }
    ::grpc::Status DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::mruv::business::DeleteBusinessResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::DeleteBusinessResponse>> AsyncDeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::DeleteBusinessResponse>>(AsyncDeleteBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::DeleteBusinessResponse>> PrepareAsyncDeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::DeleteBusinessResponse>>(PrepareAsyncDeleteBusinessRaw(context, request, cq));
    }
    ::grpc::Status AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::mruv::business::AssignOwnerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignOwnerResponse>> AsyncAssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignOwnerResponse>>(AsyncAssignOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignOwnerResponse>> PrepareAsyncAssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignOwnerResponse>>(PrepareAsyncAssignOwnerRaw(context, request, cq));
    }
    ::grpc::Status AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::mruv::business::AssignEstateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignEstateResponse>> AsyncAssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignEstateResponse>>(AsyncAssignEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignEstateResponse>> PrepareAsyncAssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignEstateResponse>>(PrepareAsyncAssignEstateRaw(context, request, cq));
    }
    ::grpc::Status UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::mruv::business::UnassignEstateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::UnassignEstateResponse>> AsyncUnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::UnassignEstateResponse>>(AsyncUnassignEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::UnassignEstateResponse>> PrepareAsyncUnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::UnassignEstateResponse>>(PrepareAsyncUnassignEstateRaw(context, request, cq));
    }
    ::grpc::Status BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::mruv::business::BuyBusinessResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::BuyBusinessResponse>> AsyncBuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::BuyBusinessResponse>>(AsyncBuyBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::BuyBusinessResponse>> PrepareAsyncBuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::business::BuyBusinessResponse>>(PrepareAsyncBuyBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::business::WatchBusinessResponse>> WatchBusiness(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::business::WatchBusinessResponse>>(WatchBusinessRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessResponse>> AsyncWatchBusiness(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessResponse>>(AsyncWatchBusinessRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessResponse>> PrepareAsyncWatchBusiness(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessResponse>>(PrepareAsyncWatchBusinessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mruv::business::WatchBusinessesResponse>> WatchBusinesses(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mruv::business::WatchBusinessesResponse>>(WatchBusinessesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessesResponse>> AsyncWatchBusinesses(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessesResponse>>(AsyncWatchBusinessesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessesResponse>> PrepareAsyncWatchBusinesses(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessesResponse>>(PrepareAsyncWatchBusinessesRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::CreateBusinessResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateBusiness(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::CreateBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) override;
      void GetBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBusiness(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) override;
      void UpdateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateBusiness(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::Business* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::DeleteBusinessResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteBusiness(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::DeleteBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response, std::function<void(::grpc::Status)>) override;
      void AssignOwner(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignOwnerResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AssignOwner(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AssignOwner(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AssignOwner(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignOwnerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response, std::function<void(::grpc::Status)>) override;
      void AssignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignEstateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AssignEstate(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AssignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AssignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::AssignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response, std::function<void(::grpc::Status)>) override;
      void UnassignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::UnassignEstateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnassignEstate(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnassignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnassignEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::UnassignEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response, std::function<void(::grpc::Status)>) override;
      void BuyBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::BuyBusinessResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BuyBusiness(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BuyBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BuyBusiness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::business::BuyBusinessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchBusiness(::grpc::ClientContext* context, ::mruv::business::WatchBusinessRequest* request, ::grpc::ClientReadReactor< ::mruv::business::WatchBusinessResponse>* reactor) override;
      #else
      void WatchBusiness(::grpc::ClientContext* context, ::mruv::business::WatchBusinessRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::business::WatchBusinessResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WatchBusinesses(::grpc::ClientContext* context, ::mruv::business::WatchBusinessesRequest* request, ::grpc::ClientReadReactor< ::mruv::business::WatchBusinessesResponse>* reactor) override;
      #else
      void WatchBusinesses(::grpc::ClientContext* context, ::mruv::business::WatchBusinessesRequest* request, ::grpc::experimental::ClientReadReactor< ::mruv::business::WatchBusinessesResponse>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mruv::business::CreateBusinessResponse>* AsyncCreateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::CreateBusinessResponse>* PrepareAsyncCreateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::CreateBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>* AsyncGetBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>* PrepareAsyncGetBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::GetBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>* AsyncUpdateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::Business>* PrepareAsyncUpdateBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::UpdateBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::DeleteBusinessResponse>* AsyncDeleteBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::DeleteBusinessResponse>* PrepareAsyncDeleteBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::DeleteBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignOwnerResponse>* AsyncAssignOwnerRaw(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignOwnerResponse>* PrepareAsyncAssignOwnerRaw(::grpc::ClientContext* context, const ::mruv::business::AssignOwnerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignEstateResponse>* AsyncAssignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::AssignEstateResponse>* PrepareAsyncAssignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::AssignEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::UnassignEstateResponse>* AsyncUnassignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::UnassignEstateResponse>* PrepareAsyncUnassignEstateRaw(::grpc::ClientContext* context, const ::mruv::business::UnassignEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::BuyBusinessResponse>* AsyncBuyBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::business::BuyBusinessResponse>* PrepareAsyncBuyBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::BuyBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::business::WatchBusinessResponse>* WatchBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessResponse>* AsyncWatchBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessResponse>* PrepareAsyncWatchBusinessRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mruv::business::WatchBusinessesResponse>* WatchBusinessesRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request) override;
    ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessesResponse>* AsyncWatchBusinessesRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mruv::business::WatchBusinessesResponse>* PrepareAsyncWatchBusinessesRaw(::grpc::ClientContext* context, const ::mruv::business::WatchBusinessesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateBusiness_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBusiness_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateBusiness_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteBusiness_;
    const ::grpc::internal::RpcMethod rpcmethod_AssignOwner_;
    const ::grpc::internal::RpcMethod rpcmethod_AssignEstate_;
    const ::grpc::internal::RpcMethod rpcmethod_UnassignEstate_;
    const ::grpc::internal::RpcMethod rpcmethod_BuyBusiness_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchBusiness_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchBusinesses_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Create a business.
    virtual ::grpc::Status CreateBusiness(::grpc::ServerContext* context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response);
    // Get a business.
    virtual ::grpc::Status GetBusiness(::grpc::ServerContext* context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response);
    // Update a business.
    virtual ::grpc::Status UpdateBusiness(::grpc::ServerContext* context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response);
    // Delete a business.
    virtual ::grpc::Status DeleteBusiness(::grpc::ServerContext* context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response);
    // Assign a business owner.
    virtual ::grpc::Status AssignOwner(::grpc::ServerContext* context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response);
    // Assign an estate to a business.
    virtual ::grpc::Status AssignEstate(::grpc::ServerContext* context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response);
    //
    virtual ::grpc::Status UnassignEstate(::grpc::ServerContext* context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response);
    // Buy a business.
    virtual ::grpc::Status BuyBusiness(::grpc::ServerContext* context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response);
    // Subscribe to business events.
    virtual ::grpc::Status WatchBusiness(::grpc::ServerContext* context, const ::mruv::business::WatchBusinessRequest* request, ::grpc::ServerWriter< ::mruv::business::WatchBusinessResponse>* writer);
    // Subscribe to all businesses events.
    virtual ::grpc::Status WatchBusinesses(::grpc::ServerContext* context, const ::mruv::business::WatchBusinessesRequest* request, ::grpc::ServerWriter< ::mruv::business::WatchBusinessesResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateBusiness() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateBusiness(::grpc::ServerContext* context, ::mruv::business::CreateBusinessRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::CreateBusinessResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBusiness() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBusiness(::grpc::ServerContext* context, ::mruv::business::GetBusinessRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::Business>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateBusiness() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_UpdateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateBusiness(::grpc::ServerContext* context, ::mruv::business::UpdateBusinessRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::Business>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteBusiness() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DeleteBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteBusiness(::grpc::ServerContext* context, ::mruv::business::DeleteBusinessRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::DeleteBusinessResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AssignOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AssignOwner() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_AssignOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignOwner(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssignOwner(::grpc::ServerContext* context, ::mruv::business::AssignOwnerRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::AssignOwnerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AssignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AssignEstate() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AssignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssignEstate(::grpc::ServerContext* context, ::mruv::business::AssignEstateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::AssignEstateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnassignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnassignEstate() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UnassignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnassignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnassignEstate(::grpc::ServerContext* context, ::mruv::business::UnassignEstateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::UnassignEstateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BuyBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BuyBusiness() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_BuyBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuyBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBuyBusiness(::grpc::ServerContext* context, ::mruv::business::BuyBusinessRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::business::BuyBusinessResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchBusiness() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_WatchBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBusiness(::grpc::ServerContext* context, ::mruv::business::WatchBusinessRequest* request, ::grpc::ServerAsyncWriter< ::mruv::business::WatchBusinessResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchBusinesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WatchBusinesses() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_WatchBusinesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusinesses(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBusinesses(::grpc::ServerContext* context, ::mruv::business::WatchBusinessesRequest* request, ::grpc::ServerAsyncWriter< ::mruv::business::WatchBusinessesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateBusiness<WithAsyncMethod_GetBusiness<WithAsyncMethod_UpdateBusiness<WithAsyncMethod_DeleteBusiness<WithAsyncMethod_AssignOwner<WithAsyncMethod_AssignEstate<WithAsyncMethod_UnassignEstate<WithAsyncMethod_BuyBusiness<WithAsyncMethod_WatchBusiness<WithAsyncMethod_WatchBusinesses<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::CreateBusinessRequest, ::mruv::business::CreateBusinessResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::CreateBusinessRequest* request, ::mruv::business::CreateBusinessResponse* response) { return this->CreateBusiness(context, request, response); }));}
    void SetMessageAllocatorFor_CreateBusiness(
        ::grpc::experimental::MessageAllocator< ::mruv::business::CreateBusinessRequest, ::mruv::business::CreateBusinessResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::CreateBusinessRequest, ::mruv::business::CreateBusinessResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::GetBusinessRequest, ::mruv::business::Business>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::GetBusinessRequest* request, ::mruv::business::Business* response) { return this->GetBusiness(context, request, response); }));}
    void SetMessageAllocatorFor_GetBusiness(
        ::grpc::experimental::MessageAllocator< ::mruv::business::GetBusinessRequest, ::mruv::business::Business>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::GetBusinessRequest, ::mruv::business::Business>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::UpdateBusinessRequest, ::mruv::business::Business>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::UpdateBusinessRequest* request, ::mruv::business::Business* response) { return this->UpdateBusiness(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateBusiness(
        ::grpc::experimental::MessageAllocator< ::mruv::business::UpdateBusinessRequest, ::mruv::business::Business>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::UpdateBusinessRequest, ::mruv::business::Business>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::DeleteBusinessRequest, ::mruv::business::DeleteBusinessResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::DeleteBusinessRequest* request, ::mruv::business::DeleteBusinessResponse* response) { return this->DeleteBusiness(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteBusiness(
        ::grpc::experimental::MessageAllocator< ::mruv::business::DeleteBusinessRequest, ::mruv::business::DeleteBusinessResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::DeleteBusinessRequest, ::mruv::business::DeleteBusinessResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AssignOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AssignOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::AssignOwnerRequest, ::mruv::business::AssignOwnerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::AssignOwnerRequest* request, ::mruv::business::AssignOwnerResponse* response) { return this->AssignOwner(context, request, response); }));}
    void SetMessageAllocatorFor_AssignOwner(
        ::grpc::experimental::MessageAllocator< ::mruv::business::AssignOwnerRequest, ::mruv::business::AssignOwnerResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::AssignOwnerRequest, ::mruv::business::AssignOwnerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AssignOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignOwner(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AssignOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AssignOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AssignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AssignEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::AssignEstateRequest, ::mruv::business::AssignEstateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::AssignEstateRequest* request, ::mruv::business::AssignEstateResponse* response) { return this->AssignEstate(context, request, response); }));}
    void SetMessageAllocatorFor_AssignEstate(
        ::grpc::experimental::MessageAllocator< ::mruv::business::AssignEstateRequest, ::mruv::business::AssignEstateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::AssignEstateRequest, ::mruv::business::AssignEstateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AssignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AssignEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AssignEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnassignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnassignEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::UnassignEstateRequest, ::mruv::business::UnassignEstateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::UnassignEstateRequest* request, ::mruv::business::UnassignEstateResponse* response) { return this->UnassignEstate(context, request, response); }));}
    void SetMessageAllocatorFor_UnassignEstate(
        ::grpc::experimental::MessageAllocator< ::mruv::business::UnassignEstateRequest, ::mruv::business::UnassignEstateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::UnassignEstateRequest, ::mruv::business::UnassignEstateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnassignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnassignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnassignEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnassignEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BuyBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BuyBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::BuyBusinessRequest, ::mruv::business::BuyBusinessResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::BuyBusinessRequest* request, ::mruv::business::BuyBusinessResponse* response) { return this->BuyBusiness(context, request, response); }));}
    void SetMessageAllocatorFor_BuyBusiness(
        ::grpc::experimental::MessageAllocator< ::mruv::business::BuyBusinessRequest, ::mruv::business::BuyBusinessResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::business::BuyBusinessRequest, ::mruv::business::BuyBusinessResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BuyBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuyBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BuyBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BuyBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::mruv::business::WatchBusinessRequest, ::mruv::business::WatchBusinessResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::WatchBusinessRequest* request) { return this->WatchBusiness(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::business::WatchBusinessResponse>* WatchBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::business::WatchBusinessResponse>* WatchBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchBusinesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WatchBusinesses() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::mruv::business::WatchBusinessesRequest, ::mruv::business::WatchBusinessesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::business::WatchBusinessesRequest* request) { return this->WatchBusinesses(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_WatchBusinesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusinesses(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mruv::business::WatchBusinessesResponse>* WatchBusinesses(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mruv::business::WatchBusinessesResponse>* WatchBusinesses(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_CreateBusiness<ExperimentalWithCallbackMethod_GetBusiness<ExperimentalWithCallbackMethod_UpdateBusiness<ExperimentalWithCallbackMethod_DeleteBusiness<ExperimentalWithCallbackMethod_AssignOwner<ExperimentalWithCallbackMethod_AssignEstate<ExperimentalWithCallbackMethod_UnassignEstate<ExperimentalWithCallbackMethod_BuyBusiness<ExperimentalWithCallbackMethod_WatchBusiness<ExperimentalWithCallbackMethod_WatchBusinesses<Service > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_CreateBusiness<ExperimentalWithCallbackMethod_GetBusiness<ExperimentalWithCallbackMethod_UpdateBusiness<ExperimentalWithCallbackMethod_DeleteBusiness<ExperimentalWithCallbackMethod_AssignOwner<ExperimentalWithCallbackMethod_AssignEstate<ExperimentalWithCallbackMethod_UnassignEstate<ExperimentalWithCallbackMethod_BuyBusiness<ExperimentalWithCallbackMethod_WatchBusiness<ExperimentalWithCallbackMethod_WatchBusinesses<Service > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateBusiness() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBusiness() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateBusiness() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_UpdateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteBusiness() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DeleteBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AssignOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AssignOwner() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_AssignOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignOwner(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AssignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AssignEstate() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AssignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnassignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnassignEstate() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UnassignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnassignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BuyBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BuyBusiness() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_BuyBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuyBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchBusiness() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_WatchBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchBusinesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WatchBusinesses() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_WatchBusinesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusinesses(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateBusiness() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateBusiness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBusiness() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBusiness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateBusiness() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_UpdateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateBusiness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteBusiness() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DeleteBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteBusiness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AssignOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AssignOwner() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_AssignOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignOwner(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssignOwner(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AssignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AssignEstate() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AssignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssignEstate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnassignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnassignEstate() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UnassignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnassignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnassignEstate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BuyBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BuyBusiness() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_BuyBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuyBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBuyBusiness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchBusiness() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_WatchBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBusiness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchBusinesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WatchBusinesses() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_WatchBusinesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusinesses(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchBusinesses(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateBusiness(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBusiness(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateBusiness(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteBusiness(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AssignOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AssignOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AssignOwner(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AssignOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignOwner(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AssignOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AssignOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AssignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AssignEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AssignEstate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AssignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AssignEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AssignEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnassignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnassignEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnassignEstate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnassignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnassignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnassignEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnassignEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BuyBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BuyBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BuyBusiness(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BuyBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuyBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BuyBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BuyBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchBusiness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchBusiness(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBusiness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBusiness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchBusinesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchBusinesses() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->WatchBusinesses(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchBusinesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchBusinesses(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBusinesses(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* WatchBusinesses(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateBusiness() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::CreateBusinessRequest, ::mruv::business::CreateBusinessResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::CreateBusinessRequest, ::mruv::business::CreateBusinessResponse>* streamer) {
                       return this->StreamedCreateBusiness(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::CreateBusinessRequest* /*request*/, ::mruv::business::CreateBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateBusiness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::CreateBusinessRequest,::mruv::business::CreateBusinessResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBusiness() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::GetBusinessRequest, ::mruv::business::Business>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::GetBusinessRequest, ::mruv::business::Business>* streamer) {
                       return this->StreamedGetBusiness(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::GetBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBusiness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::GetBusinessRequest,::mruv::business::Business>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateBusiness() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::UpdateBusinessRequest, ::mruv::business::Business>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::UpdateBusinessRequest, ::mruv::business::Business>* streamer) {
                       return this->StreamedUpdateBusiness(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::UpdateBusinessRequest* /*request*/, ::mruv::business::Business* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateBusiness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::UpdateBusinessRequest,::mruv::business::Business>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteBusiness() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::DeleteBusinessRequest, ::mruv::business::DeleteBusinessResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::DeleteBusinessRequest, ::mruv::business::DeleteBusinessResponse>* streamer) {
                       return this->StreamedDeleteBusiness(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::DeleteBusinessRequest* /*request*/, ::mruv::business::DeleteBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteBusiness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::DeleteBusinessRequest,::mruv::business::DeleteBusinessResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AssignOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AssignOwner() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::AssignOwnerRequest, ::mruv::business::AssignOwnerResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::AssignOwnerRequest, ::mruv::business::AssignOwnerResponse>* streamer) {
                       return this->StreamedAssignOwner(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AssignOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AssignOwner(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignOwnerRequest* /*request*/, ::mruv::business::AssignOwnerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAssignOwner(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::AssignOwnerRequest,::mruv::business::AssignOwnerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AssignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AssignEstate() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::AssignEstateRequest, ::mruv::business::AssignEstateResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::AssignEstateRequest, ::mruv::business::AssignEstateResponse>* streamer) {
                       return this->StreamedAssignEstate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AssignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AssignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::AssignEstateRequest* /*request*/, ::mruv::business::AssignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAssignEstate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::AssignEstateRequest,::mruv::business::AssignEstateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnassignEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnassignEstate() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::UnassignEstateRequest, ::mruv::business::UnassignEstateResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::UnassignEstateRequest, ::mruv::business::UnassignEstateResponse>* streamer) {
                       return this->StreamedUnassignEstate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnassignEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnassignEstate(::grpc::ServerContext* /*context*/, const ::mruv::business::UnassignEstateRequest* /*request*/, ::mruv::business::UnassignEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnassignEstate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::UnassignEstateRequest,::mruv::business::UnassignEstateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BuyBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BuyBusiness() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::business::BuyBusinessRequest, ::mruv::business::BuyBusinessResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::business::BuyBusinessRequest, ::mruv::business::BuyBusinessResponse>* streamer) {
                       return this->StreamedBuyBusiness(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BuyBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BuyBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::BuyBusinessRequest* /*request*/, ::mruv::business::BuyBusinessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBuyBusiness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::business::BuyBusinessRequest,::mruv::business::BuyBusinessResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateBusiness<WithStreamedUnaryMethod_GetBusiness<WithStreamedUnaryMethod_UpdateBusiness<WithStreamedUnaryMethod_DeleteBusiness<WithStreamedUnaryMethod_AssignOwner<WithStreamedUnaryMethod_AssignEstate<WithStreamedUnaryMethod_UnassignEstate<WithStreamedUnaryMethod_BuyBusiness<Service > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchBusiness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchBusiness() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::business::WatchBusinessRequest, ::mruv::business::WatchBusinessResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::mruv::business::WatchBusinessRequest, ::mruv::business::WatchBusinessResponse>* streamer) {
                       return this->StreamedWatchBusiness(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchBusiness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchBusiness(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchBusiness(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::business::WatchBusinessRequest,::mruv::business::WatchBusinessResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_WatchBusinesses : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_WatchBusinesses() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mruv::business::WatchBusinessesRequest, ::mruv::business::WatchBusinessesResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::mruv::business::WatchBusinessesRequest, ::mruv::business::WatchBusinessesResponse>* streamer) {
                       return this->StreamedWatchBusinesses(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_WatchBusinesses() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchBusinesses(::grpc::ServerContext* /*context*/, const ::mruv::business::WatchBusinessesRequest* /*request*/, ::grpc::ServerWriter< ::mruv::business::WatchBusinessesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedWatchBusinesses(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mruv::business::WatchBusinessesRequest,::mruv::business::WatchBusinessesResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_WatchBusiness<WithSplitStreamingMethod_WatchBusinesses<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateBusiness<WithStreamedUnaryMethod_GetBusiness<WithStreamedUnaryMethod_UpdateBusiness<WithStreamedUnaryMethod_DeleteBusiness<WithStreamedUnaryMethod_AssignOwner<WithStreamedUnaryMethod_AssignEstate<WithStreamedUnaryMethod_UnassignEstate<WithStreamedUnaryMethod_BuyBusiness<WithSplitStreamingMethod_WatchBusiness<WithSplitStreamingMethod_WatchBusinesses<Service > > > > > > > > > > StreamedService;
};

}  // namespace business
}  // namespace mruv


#endif  // GRPC_business_2fbusiness_2eproto__INCLUDED
