// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: items/items.proto
#ifndef GRPC_items_2fitems_2eproto__INCLUDED
#define GRPC_items_2fitems_2eproto__INCLUDED

#include "items/items.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace mruv {

// The MruV items service provides procedures for managing items and containers
class MruVItemService final {
 public:
  static constexpr char const* service_full_name() {
    return "mruv.MruVItemService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Create new item.
    virtual ::grpc::Status CreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::mruv::ItemID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> AsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(AsyncCreateItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> PrepareAsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(PrepareAsyncCreateItemRaw(context, request, cq));
    }
    // Get item by id.
    virtual ::grpc::Status GetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::Item* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> AsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(AsyncGetItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> PrepareAsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(PrepareAsyncGetItemRaw(context, request, cq));
    }
    // Delete item by id.
    virtual ::grpc::Status DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::ItemID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> AsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(AsyncDeleteItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> PrepareAsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(PrepareAsyncDeleteItemRaw(context, request, cq));
    }
    // Gets all items.
    virtual ::grpc::Status GetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::mruv::GetItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemsResponse>> AsyncGetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemsResponse>>(AsyncGetItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemsResponse>> PrepareAsyncGetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemsResponse>>(PrepareAsyncGetItemsRaw(context, request, cq));
    }
    // Create item type.
    virtual ::grpc::Status CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::mruv::ItemTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> AsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(AsyncCreateItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> PrepareAsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(PrepareAsyncCreateItemTypeRaw(context, request, cq));
    }
    // Get item type by id.
    virtual ::grpc::Status GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>> AsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>>(AsyncGetItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>> PrepareAsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>>(PrepareAsyncGetItemTypeRaw(context, request, cq));
    }
    // Delete item type by id.
    virtual ::grpc::Status DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> AsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(AsyncDeleteItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> PrepareAsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(PrepareAsyncDeleteItemTypeRaw(context, request, cq));
    }
    // Gets all item types.
    virtual ::grpc::Status GetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::mruv::GetItemTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemTypesResponse>> AsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemTypesResponse>>(AsyncGetItemTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemTypesResponse>> PrepareAsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemTypesResponse>>(PrepareAsyncGetItemTypesRaw(context, request, cq));
    }
    // Create container.
    virtual ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::mruv::ContainerID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> AsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    // Get container by id.
    virtual ::grpc::Status GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::Container* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>> AsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>>(AsyncGetContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>> PrepareAsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>>(PrepareAsyncGetContainerRaw(context, request, cq));
    }
    // Delete container by id.
    virtual ::grpc::Status DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::ContainerID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> AsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(AsyncDeleteContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> PrepareAsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(PrepareAsyncDeleteContainerRaw(context, request, cq));
    }
    // Get all containers.
    virtual ::grpc::Status GetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::mruv::GetContainersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainersResponse>> AsyncGetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainersResponse>>(AsyncGetContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainersResponse>> PrepareAsyncGetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainersResponse>>(PrepareAsyncGetContainersRaw(context, request, cq));
    }
    // Create container type.
    virtual ::grpc::Status CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::mruv::ContainerTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> AsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(AsyncCreateContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> PrepareAsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(PrepareAsyncCreateContainerTypeRaw(context, request, cq));
    }
    // Get container type by id.
    virtual ::grpc::Status GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>> AsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>>(AsyncGetContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>> PrepareAsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>>(PrepareAsyncGetContainerTypeRaw(context, request, cq));
    }
    // Detele container type by id.
    virtual ::grpc::Status DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> AsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(AsyncDeleteContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> PrepareAsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(PrepareAsyncDeleteContainerTypeRaw(context, request, cq));
    }
    // Get all container types.
    virtual ::grpc::Status GetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::mruv::GetContainerTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerTypesResponse>> AsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerTypesResponse>>(AsyncGetContainerTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerTypesResponse>> PrepareAsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerTypesResponse>>(PrepareAsyncGetContainerTypesRaw(context, request, cq));
    }
    // Get items inside a container.
    virtual ::grpc::Status GetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::mruv::GetContainerItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerItemsResponse>> AsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerItemsResponse>>(AsyncGetContainerItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerItemsResponse>> PrepareAsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerItemsResponse>>(PrepareAsyncGetContainerItemsRaw(context, request, cq));
    }
    // Pull item from container.
    virtual ::grpc::Status PullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::mruv::Item* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> AsyncPullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(AsyncPullItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> PrepareAsyncPullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(PrepareAsyncPullItemRaw(context, request, cq));
    }
    // Put item into container.
    virtual ::grpc::Status PutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::mruv::PutItemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::PutItemResponse>> AsyncPutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::PutItemResponse>>(AsyncPutItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::PutItemResponse>> PrepareAsyncPutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::PutItemResponse>>(PrepareAsyncPutItemRaw(context, request, cq));
    }
    // Sort items inside container.
    // This procedure change order of items inside container.
    virtual ::grpc::Status SortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::mruv::SortItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::SortItemsResponse>> AsyncSortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::SortItemsResponse>>(AsyncSortItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::SortItemsResponse>> PrepareAsyncSortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::SortItemsResponse>>(PrepareAsyncSortItemsRaw(context, request, cq));
    }
    // Retrieves from the container the list of items nearest to the given position.
    virtual ::grpc::Status GetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::mruv::GetNearestItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetNearestItemsResponse>> AsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetNearestItemsResponse>>(AsyncGetNearestItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetNearestItemsResponse>> PrepareAsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetNearestItemsResponse>>(PrepareAsyncGetNearestItemsRaw(context, request, cq));
    }
    // Trigger action associated with the item usage.
    virtual ::grpc::Status UseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::mruv::UseItemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::UseItemResponse>> AsyncUseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::UseItemResponse>>(AsyncUseItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::UseItemResponse>> PrepareAsyncUseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::UseItemResponse>>(PrepareAsyncUseItemRaw(context, request, cq));
    }
    // Get service health status.
    virtual ::grpc::Status GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::mruv::ServiceStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>> AsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>>(AsyncGetServiceStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>> PrepareAsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>>(PrepareAsyncGetServiceStatusRaw(context, request, cq));
    }
    // Get service current version.
    virtual ::grpc::Status GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::mruv::VersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>> AsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>>(AsyncGetServiceVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>> PrepareAsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>>(PrepareAsyncGetServiceVersionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Create new item.
      virtual void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get item by id.
      virtual void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Delete item by id.
      virtual void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Gets all items.
      virtual void GetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest* request, ::mruv::GetItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest* request, ::mruv::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Create item type.
      virtual void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get item type by id.
      virtual void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Delete item type by id.
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Gets all item types.
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest* request, ::mruv::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest* request, ::mruv::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Create container.
      virtual void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get container by id.
      virtual void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Delete container by id.
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get all containers.
      virtual void GetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest* request, ::mruv::GetContainersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest* request, ::mruv::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Create container type.
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get container type by id.
      virtual void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Detele container type by id.
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get all container types.
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest* request, ::mruv::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest* request, ::mruv::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get items inside a container.
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest* request, ::mruv::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest* request, ::mruv::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Pull item from container.
      virtual void PullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Put item into container.
      virtual void PutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest* request, ::mruv::PutItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::PutItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest* request, ::mruv::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Sort items inside container.
      // This procedure change order of items inside container.
      virtual void SortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest* request, ::mruv::SortItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::SortItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest* request, ::mruv::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Retrieves from the container the list of items nearest to the given position.
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest* request, ::mruv::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest* request, ::mruv::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Trigger action associated with the item usage.
      virtual void UseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest* request, ::mruv::UseItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::UseItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest* request, ::mruv::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get service health status.
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // Get service current version.
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* AsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* PrepareAsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* AsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* PrepareAsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* AsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* PrepareAsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemsResponse>* AsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemsResponse>* PrepareAsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* AsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* PrepareAsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>* AsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>* PrepareAsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* AsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* PrepareAsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemTypesResponse>* AsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetItemTypesResponse>* PrepareAsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>* AsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>* PrepareAsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* AsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* PrepareAsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainersResponse>* AsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainersResponse>* PrepareAsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* AsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* PrepareAsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>* AsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>* PrepareAsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* AsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* PrepareAsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerTypesResponse>* AsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerTypesResponse>* PrepareAsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerItemsResponse>* AsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetContainerItemsResponse>* PrepareAsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* AsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* PrepareAsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::PutItemResponse>* AsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::PutItemResponse>* PrepareAsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::SortItemsResponse>* AsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::SortItemsResponse>* PrepareAsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetNearestItemsResponse>* AsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::GetNearestItemsResponse>* PrepareAsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::UseItemResponse>* AsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::UseItemResponse>* PrepareAsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>* AsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>* PrepareAsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>* AsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>* PrepareAsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::mruv::ItemID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> AsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(AsyncCreateItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> PrepareAsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(PrepareAsyncCreateItemRaw(context, request, cq));
    }
    ::grpc::Status GetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::Item* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> AsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(AsyncGetItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> PrepareAsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(PrepareAsyncGetItemRaw(context, request, cq));
    }
    ::grpc::Status DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::ItemID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> AsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(AsyncDeleteItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> PrepareAsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(PrepareAsyncDeleteItemRaw(context, request, cq));
    }
    ::grpc::Status GetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::mruv::GetItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemsResponse>> AsyncGetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemsResponse>>(AsyncGetItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemsResponse>> PrepareAsyncGetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemsResponse>>(PrepareAsyncGetItemsRaw(context, request, cq));
    }
    ::grpc::Status CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::mruv::ItemTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> AsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(AsyncCreateItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> PrepareAsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(PrepareAsyncCreateItemTypeRaw(context, request, cq));
    }
    ::grpc::Status GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>> AsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>>(AsyncGetItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>> PrepareAsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>>(PrepareAsyncGetItemTypeRaw(context, request, cq));
    }
    ::grpc::Status DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> AsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(AsyncDeleteItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> PrepareAsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(PrepareAsyncDeleteItemTypeRaw(context, request, cq));
    }
    ::grpc::Status GetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::mruv::GetItemTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemTypesResponse>> AsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemTypesResponse>>(AsyncGetItemTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemTypesResponse>> PrepareAsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetItemTypesResponse>>(PrepareAsyncGetItemTypesRaw(context, request, cq));
    }
    ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::mruv::ContainerID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> AsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    ::grpc::Status GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::Container* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>> AsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>>(AsyncGetContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>> PrepareAsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>>(PrepareAsyncGetContainerRaw(context, request, cq));
    }
    ::grpc::Status DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::ContainerID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> AsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(AsyncDeleteContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> PrepareAsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(PrepareAsyncDeleteContainerRaw(context, request, cq));
    }
    ::grpc::Status GetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::mruv::GetContainersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainersResponse>> AsyncGetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainersResponse>>(AsyncGetContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainersResponse>> PrepareAsyncGetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainersResponse>>(PrepareAsyncGetContainersRaw(context, request, cq));
    }
    ::grpc::Status CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::mruv::ContainerTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> AsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(AsyncCreateContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> PrepareAsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(PrepareAsyncCreateContainerTypeRaw(context, request, cq));
    }
    ::grpc::Status GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>> AsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>>(AsyncGetContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>> PrepareAsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>>(PrepareAsyncGetContainerTypeRaw(context, request, cq));
    }
    ::grpc::Status DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> AsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(AsyncDeleteContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> PrepareAsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(PrepareAsyncDeleteContainerTypeRaw(context, request, cq));
    }
    ::grpc::Status GetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::mruv::GetContainerTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerTypesResponse>> AsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerTypesResponse>>(AsyncGetContainerTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerTypesResponse>> PrepareAsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerTypesResponse>>(PrepareAsyncGetContainerTypesRaw(context, request, cq));
    }
    ::grpc::Status GetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::mruv::GetContainerItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerItemsResponse>> AsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerItemsResponse>>(AsyncGetContainerItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerItemsResponse>> PrepareAsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerItemsResponse>>(PrepareAsyncGetContainerItemsRaw(context, request, cq));
    }
    ::grpc::Status PullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::mruv::Item* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> AsyncPullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(AsyncPullItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> PrepareAsyncPullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(PrepareAsyncPullItemRaw(context, request, cq));
    }
    ::grpc::Status PutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::mruv::PutItemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::PutItemResponse>> AsyncPutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::PutItemResponse>>(AsyncPutItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::PutItemResponse>> PrepareAsyncPutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::PutItemResponse>>(PrepareAsyncPutItemRaw(context, request, cq));
    }
    ::grpc::Status SortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::mruv::SortItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::SortItemsResponse>> AsyncSortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::SortItemsResponse>>(AsyncSortItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::SortItemsResponse>> PrepareAsyncSortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::SortItemsResponse>>(PrepareAsyncSortItemsRaw(context, request, cq));
    }
    ::grpc::Status GetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::mruv::GetNearestItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetNearestItemsResponse>> AsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetNearestItemsResponse>>(AsyncGetNearestItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetNearestItemsResponse>> PrepareAsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::GetNearestItemsResponse>>(PrepareAsyncGetNearestItemsRaw(context, request, cq));
    }
    ::grpc::Status UseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::mruv::UseItemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::UseItemResponse>> AsyncUseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::UseItemResponse>>(AsyncUseItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::UseItemResponse>> PrepareAsyncUseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::UseItemResponse>>(PrepareAsyncUseItemRaw(context, request, cq));
    }
    ::grpc::Status GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::mruv::ServiceStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>> AsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>>(AsyncGetServiceStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>> PrepareAsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>>(PrepareAsyncGetServiceStatusRaw(context, request, cq));
    }
    ::grpc::Status GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::mruv::VersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>> AsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>>(AsyncGetServiceVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>> PrepareAsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>>(PrepareAsyncGetServiceVersionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest* request, ::mruv::GetItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetItems(::grpc::ClientContext* context, const ::mruv::GetItemsRequest* request, ::mruv::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) override;
      void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) override;
      void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest* request, ::mruv::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetItemTypes(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest* request, ::mruv::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) override;
      void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) override;
      void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest* request, ::mruv::GetContainersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainers(::grpc::ClientContext* context, const ::mruv::GetContainersRequest* request, ::mruv::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) override;
      void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) override;
      void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest* request, ::mruv::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest* request, ::mruv::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest* request, ::mruv::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainerItems(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest* request, ::mruv::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      void PullItem(::grpc::ClientContext* context, const ::mruv::PullItemRequest* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest* request, ::mruv::PutItemResponse* response, std::function<void(::grpc::Status)>) override;
      void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::PutItemResponse* response, std::function<void(::grpc::Status)>) override;
      void PutItem(::grpc::ClientContext* context, const ::mruv::PutItemRequest* request, ::mruv::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest* request, ::mruv::SortItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::SortItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void SortItems(::grpc::ClientContext* context, const ::mruv::SortItemsRequest* request, ::mruv::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest* request, ::mruv::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNearestItems(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest* request, ::mruv::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest* request, ::mruv::UseItemResponse* response, std::function<void(::grpc::Status)>) override;
      void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::UseItemResponse* response, std::function<void(::grpc::Status)>) override;
      void UseItem(::grpc::ClientContext* context, const ::mruv::UseItemRequest* request, ::mruv::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* AsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* PrepareAsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* AsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* PrepareAsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* AsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* PrepareAsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetItemsResponse>* AsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetItemsResponse>* PrepareAsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::GetItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* AsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* PrepareAsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>* AsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>* PrepareAsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* AsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* PrepareAsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetItemTypesResponse>* AsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetItemTypesResponse>* PrepareAsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Container>* AsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Container>* PrepareAsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* AsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* PrepareAsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetContainersResponse>* AsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetContainersResponse>* PrepareAsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::GetContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* AsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* PrepareAsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>* AsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>* PrepareAsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* AsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* PrepareAsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerTypesResponse>* AsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerTypesResponse>* PrepareAsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerItemsResponse>* AsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetContainerItemsResponse>* PrepareAsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* AsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* PrepareAsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::PullItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::PutItemResponse>* AsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::PutItemResponse>* PrepareAsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::PutItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::SortItemsResponse>* AsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::SortItemsResponse>* PrepareAsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::SortItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetNearestItemsResponse>* AsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::GetNearestItemsResponse>* PrepareAsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::UseItemResponse>* AsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::UseItemResponse>* PrepareAsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::UseItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>* AsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>* PrepareAsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>* AsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>* PrepareAsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateItem_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItem_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteItem_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItems_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateItemType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItemType_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteItemType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItemTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainers_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateContainerType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainerType_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteContainerType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainerTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainerItems_;
    const ::grpc::internal::RpcMethod rpcmethod_PullItem_;
    const ::grpc::internal::RpcMethod rpcmethod_PutItem_;
    const ::grpc::internal::RpcMethod rpcmethod_SortItems_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNearestItems_;
    const ::grpc::internal::RpcMethod rpcmethod_UseItem_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServiceStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServiceVersion_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Create new item.
    virtual ::grpc::Status CreateItem(::grpc::ServerContext* context, const ::mruv::Item* request, ::mruv::ItemID* response);
    // Get item by id.
    virtual ::grpc::Status GetItem(::grpc::ServerContext* context, const ::mruv::ItemID* request, ::mruv::Item* response);
    // Delete item by id.
    virtual ::grpc::Status DeleteItem(::grpc::ServerContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response);
    // Gets all items.
    virtual ::grpc::Status GetItems(::grpc::ServerContext* context, const ::mruv::GetItemsRequest* request, ::mruv::GetItemsResponse* response);
    // Create item type.
    virtual ::grpc::Status CreateItemType(::grpc::ServerContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response);
    // Get item type by id.
    virtual ::grpc::Status GetItemType(::grpc::ServerContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response);
    // Delete item type by id.
    virtual ::grpc::Status DeleteItemType(::grpc::ServerContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response);
    // Gets all item types.
    virtual ::grpc::Status GetItemTypes(::grpc::ServerContext* context, const ::mruv::GetItemTypesRequest* request, ::mruv::GetItemTypesResponse* response);
    // Create container.
    virtual ::grpc::Status CreateContainer(::grpc::ServerContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response);
    // Get container by id.
    virtual ::grpc::Status GetContainer(::grpc::ServerContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response);
    // Delete container by id.
    virtual ::grpc::Status DeleteContainer(::grpc::ServerContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response);
    // Get all containers.
    virtual ::grpc::Status GetContainers(::grpc::ServerContext* context, const ::mruv::GetContainersRequest* request, ::mruv::GetContainersResponse* response);
    // Create container type.
    virtual ::grpc::Status CreateContainerType(::grpc::ServerContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response);
    // Get container type by id.
    virtual ::grpc::Status GetContainerType(::grpc::ServerContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response);
    // Detele container type by id.
    virtual ::grpc::Status DeleteContainerType(::grpc::ServerContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response);
    // Get all container types.
    virtual ::grpc::Status GetContainerTypes(::grpc::ServerContext* context, const ::mruv::GetContainerTypesRequest* request, ::mruv::GetContainerTypesResponse* response);
    // Get items inside a container.
    virtual ::grpc::Status GetContainerItems(::grpc::ServerContext* context, const ::mruv::GetContainerItemsRequest* request, ::mruv::GetContainerItemsResponse* response);
    // Pull item from container.
    virtual ::grpc::Status PullItem(::grpc::ServerContext* context, const ::mruv::PullItemRequest* request, ::mruv::Item* response);
    // Put item into container.
    virtual ::grpc::Status PutItem(::grpc::ServerContext* context, const ::mruv::PutItemRequest* request, ::mruv::PutItemResponse* response);
    // Sort items inside container.
    // This procedure change order of items inside container.
    virtual ::grpc::Status SortItems(::grpc::ServerContext* context, const ::mruv::SortItemsRequest* request, ::mruv::SortItemsResponse* response);
    // Retrieves from the container the list of items nearest to the given position.
    virtual ::grpc::Status GetNearestItems(::grpc::ServerContext* context, const ::mruv::GetNearestItemsRequest* request, ::mruv::GetNearestItemsResponse* response);
    // Trigger action associated with the item usage.
    virtual ::grpc::Status UseItem(::grpc::ServerContext* context, const ::mruv::UseItemRequest* request, ::mruv::UseItemResponse* response);
    // Get service health status.
    virtual ::grpc::Status GetServiceStatus(::grpc::ServerContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response);
    // Get service current version.
    virtual ::grpc::Status GetServiceVersion(::grpc::ServerContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateItem() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItem(::grpc::ServerContext* context, ::mruv::Item* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItem() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItem(::grpc::ServerContext* context, ::mruv::ItemID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::Item>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteItem() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItem(::grpc::ServerContext* context, ::mruv::ItemID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItems() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::GetItemsRequest* /*request*/, ::mruv::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItems(::grpc::ServerContext* context, ::mruv::GetItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::GetItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateItemType() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItemType(::grpc::ServerContext* context, ::mruv::ItemType* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItemType() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemType(::grpc::ServerContext* context, ::mruv::ItemTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItemType(::grpc::ServerContext* context, ::mruv::ItemTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetItemTypesRequest* /*request*/, ::mruv::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemTypes(::grpc::ServerContext* context, ::mruv::GetItemTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::GetItemTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateContainer() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainer(::grpc::ServerContext* context, ::mruv::Container* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainer() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainer(::grpc::ServerContext* context, ::mruv::ContainerID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::Container>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainer(::grpc::ServerContext* context, ::mruv::ContainerID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainers() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::GetContainersRequest* /*request*/, ::mruv::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainers(::grpc::ServerContext* context, ::mruv::GetContainersRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::GetContainersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainerType(::grpc::ServerContext* context, ::mruv::ContainerType* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainerType() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerType(::grpc::ServerContext* context, ::mruv::ContainerTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainerType(::grpc::ServerContext* context, ::mruv::ContainerTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerTypesRequest* /*request*/, ::mruv::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerTypes(::grpc::ServerContext* context, ::mruv::GetContainerTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::GetContainerTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerItemsRequest* /*request*/, ::mruv::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerItems(::grpc::ServerContext* context, ::mruv::GetContainerItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::GetContainerItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PullItem() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPullItem(::grpc::ServerContext* context, ::mruv::PullItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::Item>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutItem() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::PutItemRequest* /*request*/, ::mruv::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutItem(::grpc::ServerContext* context, ::mruv::PutItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::PutItemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SortItems() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::SortItemsRequest* /*request*/, ::mruv::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSortItems(::grpc::ServerContext* context, ::mruv::SortItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::SortItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::GetNearestItemsRequest* /*request*/, ::mruv::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNearestItems(::grpc::ServerContext* context, ::mruv::GetNearestItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::GetNearestItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UseItem() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::UseItemRequest* /*request*/, ::mruv::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUseItem(::grpc::ServerContext* context, ::mruv::UseItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::UseItemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceStatus(::grpc::ServerContext* context, ::mruv::ServiceStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ServiceStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceVersion(::grpc::ServerContext* context, ::mruv::VersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::VersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateItem<WithAsyncMethod_GetItem<WithAsyncMethod_DeleteItem<WithAsyncMethod_GetItems<WithAsyncMethod_CreateItemType<WithAsyncMethod_GetItemType<WithAsyncMethod_DeleteItemType<WithAsyncMethod_GetItemTypes<WithAsyncMethod_CreateContainer<WithAsyncMethod_GetContainer<WithAsyncMethod_DeleteContainer<WithAsyncMethod_GetContainers<WithAsyncMethod_CreateContainerType<WithAsyncMethod_GetContainerType<WithAsyncMethod_DeleteContainerType<WithAsyncMethod_GetContainerTypes<WithAsyncMethod_GetContainerItems<WithAsyncMethod_PullItem<WithAsyncMethod_PutItem<WithAsyncMethod_SortItems<WithAsyncMethod_GetNearestItems<WithAsyncMethod_UseItem<WithAsyncMethod_GetServiceStatus<WithAsyncMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateItem() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Item, ::mruv::ItemID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::Item* request, ::mruv::ItemID* response) { return this->CreateItem(context, request, response); }));}
    void SetMessageAllocatorFor_CreateItem(
        ::grpc::experimental::MessageAllocator< ::mruv::Item, ::mruv::ItemID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Item, ::mruv::ItemID>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItem() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::Item>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ItemID* request, ::mruv::Item* response) { return this->GetItem(context, request, response); }));}
    void SetMessageAllocatorFor_GetItem(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemID, ::mruv::Item>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::Item>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteItem() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::ItemID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response) { return this->DeleteItem(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteItem(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemID, ::mruv::ItemID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::ItemID>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItems() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetItemsRequest, ::mruv::GetItemsResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::GetItemsRequest* request, ::mruv::GetItemsResponse* response) { return this->GetItems(context, request, response); }));}
    void SetMessageAllocatorFor_GetItems(
        ::grpc::experimental::MessageAllocator< ::mruv::GetItemsRequest, ::mruv::GetItemsResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetItemsRequest, ::mruv::GetItemsResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::GetItemsRequest* /*request*/, ::mruv::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::GetItemsRequest* /*request*/, ::mruv::GetItemsResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateItemType() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemType, ::mruv::ItemTypeID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response) { return this->CreateItemType(context, request, response); }));}
    void SetMessageAllocatorFor_CreateItemType(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemType, ::mruv::ItemTypeID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemType, ::mruv::ItemTypeID>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItemType(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItemType() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemType>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response) { return this->GetItemType(context, request, response); }));}
    void SetMessageAllocatorFor_GetItemType(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemTypeID, ::mruv::ItemType>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemType>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemType(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteItemType() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemTypeID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response) { return this->DeleteItemType(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteItemType(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemTypeID, ::mruv::ItemTypeID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemTypeID>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItemType(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItemTypes() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetItemTypesRequest, ::mruv::GetItemTypesResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::GetItemTypesRequest* request, ::mruv::GetItemTypesResponse* response) { return this->GetItemTypes(context, request, response); }));}
    void SetMessageAllocatorFor_GetItemTypes(
        ::grpc::experimental::MessageAllocator< ::mruv::GetItemTypesRequest, ::mruv::GetItemTypesResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetItemTypesRequest, ::mruv::GetItemTypesResponse>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetItemTypesRequest* /*request*/, ::mruv::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemTypes(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::GetItemTypesRequest* /*request*/, ::mruv::GetItemTypesResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateContainer() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Container, ::mruv::ContainerID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response) { return this->CreateContainer(context, request, response); }));}
    void SetMessageAllocatorFor_CreateContainer(
        ::grpc::experimental::MessageAllocator< ::mruv::Container, ::mruv::ContainerID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Container, ::mruv::ContainerID>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainer(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainer() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::Container>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response) { return this->GetContainer(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainer(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerID, ::mruv::Container>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::Container>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainer(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteContainer() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::ContainerID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response) { return this->DeleteContainer(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteContainer(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerID, ::mruv::ContainerID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::ContainerID>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainer(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainers() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetContainersRequest, ::mruv::GetContainersResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::GetContainersRequest* request, ::mruv::GetContainersResponse* response) { return this->GetContainers(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainers(
        ::grpc::experimental::MessageAllocator< ::mruv::GetContainersRequest, ::mruv::GetContainersResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetContainersRequest, ::mruv::GetContainersResponse>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::GetContainersRequest* /*request*/, ::mruv::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainers(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::GetContainersRequest* /*request*/, ::mruv::GetContainersResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateContainerType() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerType, ::mruv::ContainerTypeID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response) { return this->CreateContainerType(context, request, response); }));}
    void SetMessageAllocatorFor_CreateContainerType(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerType, ::mruv::ContainerTypeID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerType, ::mruv::ContainerTypeID>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainerType(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainerType() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerType>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response) { return this->GetContainerType(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainerType(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerTypeID, ::mruv::ContainerType>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerType>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerType(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteContainerType() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response) { return this->DeleteContainerType(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteContainerType(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainerType(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainerTypes() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetContainerTypesRequest, ::mruv::GetContainerTypesResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::GetContainerTypesRequest* request, ::mruv::GetContainerTypesResponse* response) { return this->GetContainerTypes(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainerTypes(
        ::grpc::experimental::MessageAllocator< ::mruv::GetContainerTypesRequest, ::mruv::GetContainerTypesResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetContainerTypesRequest, ::mruv::GetContainerTypesResponse>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerTypesRequest* /*request*/, ::mruv::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerTypes(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::GetContainerTypesRequest* /*request*/, ::mruv::GetContainerTypesResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainerItems() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetContainerItemsRequest, ::mruv::GetContainerItemsResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::GetContainerItemsRequest* request, ::mruv::GetContainerItemsResponse* response) { return this->GetContainerItems(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainerItems(
        ::grpc::experimental::MessageAllocator< ::mruv::GetContainerItemsRequest, ::mruv::GetContainerItemsResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetContainerItemsRequest, ::mruv::GetContainerItemsResponse>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerItemsRequest* /*request*/, ::mruv::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::GetContainerItemsRequest* /*request*/, ::mruv::GetContainerItemsResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PullItem() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::PullItemRequest, ::mruv::Item>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::PullItemRequest* request, ::mruv::Item* response) { return this->PullItem(context, request, response); }));}
    void SetMessageAllocatorFor_PullItem(
        ::grpc::experimental::MessageAllocator< ::mruv::PullItemRequest, ::mruv::Item>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::PullItemRequest, ::mruv::Item>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* PullItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PutItem() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::PutItemRequest, ::mruv::PutItemResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::PutItemRequest* request, ::mruv::PutItemResponse* response) { return this->PutItem(context, request, response); }));}
    void SetMessageAllocatorFor_PutItem(
        ::grpc::experimental::MessageAllocator< ::mruv::PutItemRequest, ::mruv::PutItemResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::PutItemRequest, ::mruv::PutItemResponse>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::PutItemRequest* /*request*/, ::mruv::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* PutItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::PutItemRequest* /*request*/, ::mruv::PutItemResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SortItems() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::SortItemsRequest, ::mruv::SortItemsResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::SortItemsRequest* request, ::mruv::SortItemsResponse* response) { return this->SortItems(context, request, response); }));}
    void SetMessageAllocatorFor_SortItems(
        ::grpc::experimental::MessageAllocator< ::mruv::SortItemsRequest, ::mruv::SortItemsResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::SortItemsRequest, ::mruv::SortItemsResponse>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::SortItemsRequest* /*request*/, ::mruv::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* SortItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::SortItemsRequest* /*request*/, ::mruv::SortItemsResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNearestItems() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetNearestItemsRequest, ::mruv::GetNearestItemsResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::GetNearestItemsRequest* request, ::mruv::GetNearestItemsResponse* response) { return this->GetNearestItems(context, request, response); }));}
    void SetMessageAllocatorFor_GetNearestItems(
        ::grpc::experimental::MessageAllocator< ::mruv::GetNearestItemsRequest, ::mruv::GetNearestItemsResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::GetNearestItemsRequest, ::mruv::GetNearestItemsResponse>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::GetNearestItemsRequest* /*request*/, ::mruv::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetNearestItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::GetNearestItemsRequest* /*request*/, ::mruv::GetNearestItemsResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UseItem() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::UseItemRequest, ::mruv::UseItemResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::UseItemRequest* request, ::mruv::UseItemResponse* response) { return this->UseItem(context, request, response); }));}
    void SetMessageAllocatorFor_UseItem(
        ::grpc::experimental::MessageAllocator< ::mruv::UseItemRequest, ::mruv::UseItemResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::UseItemRequest, ::mruv::UseItemResponse>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::UseItemRequest* /*request*/, ::mruv::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* UseItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::UseItemRequest* /*request*/, ::mruv::UseItemResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetServiceStatus() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response) { return this->GetServiceStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetServiceStatus(
        ::grpc::experimental::MessageAllocator< ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceStatus(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetServiceVersion() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::VersionRequest, ::mruv::VersionResponse>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response) { return this->GetServiceVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetServiceVersion(
        ::grpc::experimental::MessageAllocator< ::mruv::VersionRequest, ::mruv::VersionResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::VersionRequest, ::mruv::VersionResponse>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceVersion(::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) { return nullptr; }
  };
  typedef ExperimentalWithCallbackMethod_CreateItem<ExperimentalWithCallbackMethod_GetItem<ExperimentalWithCallbackMethod_DeleteItem<ExperimentalWithCallbackMethod_GetItems<ExperimentalWithCallbackMethod_CreateItemType<ExperimentalWithCallbackMethod_GetItemType<ExperimentalWithCallbackMethod_DeleteItemType<ExperimentalWithCallbackMethod_GetItemTypes<ExperimentalWithCallbackMethod_CreateContainer<ExperimentalWithCallbackMethod_GetContainer<ExperimentalWithCallbackMethod_DeleteContainer<ExperimentalWithCallbackMethod_GetContainers<ExperimentalWithCallbackMethod_CreateContainerType<ExperimentalWithCallbackMethod_GetContainerType<ExperimentalWithCallbackMethod_DeleteContainerType<ExperimentalWithCallbackMethod_GetContainerTypes<ExperimentalWithCallbackMethod_GetContainerItems<ExperimentalWithCallbackMethod_PullItem<ExperimentalWithCallbackMethod_PutItem<ExperimentalWithCallbackMethod_SortItems<ExperimentalWithCallbackMethod_GetNearestItems<ExperimentalWithCallbackMethod_UseItem<ExperimentalWithCallbackMethod_GetServiceStatus<ExperimentalWithCallbackMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateItem() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItem() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteItem() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItems() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::GetItemsRequest* /*request*/, ::mruv::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateItemType() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItemType() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetItemTypesRequest* /*request*/, ::mruv::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateContainer() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainer() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainers() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::GetContainersRequest* /*request*/, ::mruv::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainerType() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerTypesRequest* /*request*/, ::mruv::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerItemsRequest* /*request*/, ::mruv::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PullItem() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutItem() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::PutItemRequest* /*request*/, ::mruv::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SortItems() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::SortItemsRequest* /*request*/, ::mruv::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::GetNearestItemsRequest* /*request*/, ::mruv::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UseItem() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::UseItemRequest* /*request*/, ::mruv::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateItem() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItem() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteItem() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItems() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::GetItemsRequest* /*request*/, ::mruv::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateItemType() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItemType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItemType() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItemType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetItemTypesRequest* /*request*/, ::mruv::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateContainer() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainer() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainers() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::GetContainersRequest* /*request*/, ::mruv::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainerType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainerType() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainerType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerTypesRequest* /*request*/, ::mruv::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerItemsRequest* /*request*/, ::mruv::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PullItem() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPullItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutItem() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::PutItemRequest* /*request*/, ::mruv::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SortItems() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::SortItemsRequest* /*request*/, ::mruv::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSortItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::GetNearestItemsRequest* /*request*/, ::mruv::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNearestItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UseItem() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::UseItemRequest* /*request*/, ::mruv::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUseItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItems() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::GetItemsRequest* /*request*/, ::mruv::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateItemType() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateItemType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItemType(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItemType() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItemType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemType(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteItemType() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteItemType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItemType(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItemTypes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItemTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetItemTypesRequest* /*request*/, ::mruv::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemTypes(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateContainer() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateContainer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainer(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainer() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainer(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteContainer() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteContainer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainer(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainers() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::GetContainersRequest* /*request*/, ::mruv::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainers(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateContainerType() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateContainerType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainerType(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainerType() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainerType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerType(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteContainerType() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteContainerType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainerType(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainerTypes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainerTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerTypesRequest* /*request*/, ::mruv::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerTypes(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainerItems() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainerItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerItemsRequest* /*request*/, ::mruv::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PullItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PullItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* PullItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PutItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PutItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::PutItemRequest* /*request*/, ::mruv::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* PutItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SortItems() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SortItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::SortItemsRequest* /*request*/, ::mruv::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* SortItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNearestItems() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNearestItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::GetNearestItemsRequest* /*request*/, ::mruv::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetNearestItems(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UseItem() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UseItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::UseItemRequest* /*request*/, ::mruv::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* UseItem(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetServiceStatus() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServiceStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceStatus(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetServiceVersion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::experimental::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServiceVersion(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceVersion(::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateItem() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::Item, ::mruv::ItemID>(std::bind(&WithStreamedUnaryMethod_CreateItem<BaseClass>::StreamedCreateItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::Item,::mruv::ItemID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItem() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ItemID, ::mruv::Item>(std::bind(&WithStreamedUnaryMethod_GetItem<BaseClass>::StreamedGetItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemID,::mruv::Item>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteItem() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ItemID, ::mruv::ItemID>(std::bind(&WithStreamedUnaryMethod_DeleteItem<BaseClass>::StreamedDeleteItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemID,::mruv::ItemID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItems() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::GetItemsRequest, ::mruv::GetItemsResponse>(std::bind(&WithStreamedUnaryMethod_GetItems<BaseClass>::StreamedGetItems, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::GetItemsRequest* /*request*/, ::mruv::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::GetItemsRequest,::mruv::GetItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateItemType() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ItemType, ::mruv::ItemTypeID>(std::bind(&WithStreamedUnaryMethod_CreateItemType<BaseClass>::StreamedCreateItemType, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateItemType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemType,::mruv::ItemTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItemType() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemType>(std::bind(&WithStreamedUnaryMethod_GetItemType<BaseClass>::StreamedGetItemType, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItemType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemTypeID,::mruv::ItemType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemTypeID>(std::bind(&WithStreamedUnaryMethod_DeleteItemType<BaseClass>::StreamedDeleteItemType, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteItemType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemTypeID,::mruv::ItemTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::GetItemTypesRequest, ::mruv::GetItemTypesResponse>(std::bind(&WithStreamedUnaryMethod_GetItemTypes<BaseClass>::StreamedGetItemTypes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetItemTypesRequest* /*request*/, ::mruv::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItemTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::GetItemTypesRequest,::mruv::GetItemTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateContainer() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::Container, ::mruv::ContainerID>(std::bind(&WithStreamedUnaryMethod_CreateContainer<BaseClass>::StreamedCreateContainer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::Container,::mruv::ContainerID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainer() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ContainerID, ::mruv::Container>(std::bind(&WithStreamedUnaryMethod_GetContainer<BaseClass>::StreamedGetContainer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerID,::mruv::Container>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ContainerID, ::mruv::ContainerID>(std::bind(&WithStreamedUnaryMethod_DeleteContainer<BaseClass>::StreamedDeleteContainer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerID,::mruv::ContainerID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainers() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::GetContainersRequest, ::mruv::GetContainersResponse>(std::bind(&WithStreamedUnaryMethod_GetContainers<BaseClass>::StreamedGetContainers, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::GetContainersRequest* /*request*/, ::mruv::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::GetContainersRequest,::mruv::GetContainersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ContainerType, ::mruv::ContainerTypeID>(std::bind(&WithStreamedUnaryMethod_CreateContainerType<BaseClass>::StreamedCreateContainerType, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateContainerType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerType,::mruv::ContainerTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainerType() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerType>(std::bind(&WithStreamedUnaryMethod_GetContainerType<BaseClass>::StreamedGetContainerType, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainerType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerTypeID,::mruv::ContainerType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>(std::bind(&WithStreamedUnaryMethod_DeleteContainerType<BaseClass>::StreamedDeleteContainerType, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteContainerType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerTypeID,::mruv::ContainerTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::GetContainerTypesRequest, ::mruv::GetContainerTypesResponse>(std::bind(&WithStreamedUnaryMethod_GetContainerTypes<BaseClass>::StreamedGetContainerTypes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerTypesRequest* /*request*/, ::mruv::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainerTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::GetContainerTypesRequest,::mruv::GetContainerTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::GetContainerItemsRequest, ::mruv::GetContainerItemsResponse>(std::bind(&WithStreamedUnaryMethod_GetContainerItems<BaseClass>::StreamedGetContainerItems, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::GetContainerItemsRequest* /*request*/, ::mruv::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainerItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::GetContainerItemsRequest,::mruv::GetContainerItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PullItem() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::PullItemRequest, ::mruv::Item>(std::bind(&WithStreamedUnaryMethod_PullItem<BaseClass>::StreamedPullItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPullItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::PullItemRequest,::mruv::Item>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutItem() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::PutItemRequest, ::mruv::PutItemResponse>(std::bind(&WithStreamedUnaryMethod_PutItem<BaseClass>::StreamedPutItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::PutItemRequest* /*request*/, ::mruv::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::PutItemRequest,::mruv::PutItemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SortItems() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::SortItemsRequest, ::mruv::SortItemsResponse>(std::bind(&WithStreamedUnaryMethod_SortItems<BaseClass>::StreamedSortItems, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::SortItemsRequest* /*request*/, ::mruv::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSortItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::SortItemsRequest,::mruv::SortItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::GetNearestItemsRequest, ::mruv::GetNearestItemsResponse>(std::bind(&WithStreamedUnaryMethod_GetNearestItems<BaseClass>::StreamedGetNearestItems, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::GetNearestItemsRequest* /*request*/, ::mruv::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNearestItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::GetNearestItemsRequest,::mruv::GetNearestItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UseItem() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::UseItemRequest, ::mruv::UseItemResponse>(std::bind(&WithStreamedUnaryMethod_UseItem<BaseClass>::StreamedUseItem, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::UseItemRequest* /*request*/, ::mruv::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUseItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::UseItemRequest,::mruv::UseItemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>(std::bind(&WithStreamedUnaryMethod_GetServiceStatus<BaseClass>::StreamedGetServiceStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServiceStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ServiceStatusRequest,::mruv::ServiceStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::VersionRequest, ::mruv::VersionResponse>(std::bind(&WithStreamedUnaryMethod_GetServiceVersion<BaseClass>::StreamedGetServiceVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServiceVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::VersionRequest,::mruv::VersionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateItem<WithStreamedUnaryMethod_GetItem<WithStreamedUnaryMethod_DeleteItem<WithStreamedUnaryMethod_GetItems<WithStreamedUnaryMethod_CreateItemType<WithStreamedUnaryMethod_GetItemType<WithStreamedUnaryMethod_DeleteItemType<WithStreamedUnaryMethod_GetItemTypes<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_GetContainer<WithStreamedUnaryMethod_DeleteContainer<WithStreamedUnaryMethod_GetContainers<WithStreamedUnaryMethod_CreateContainerType<WithStreamedUnaryMethod_GetContainerType<WithStreamedUnaryMethod_DeleteContainerType<WithStreamedUnaryMethod_GetContainerTypes<WithStreamedUnaryMethod_GetContainerItems<WithStreamedUnaryMethod_PullItem<WithStreamedUnaryMethod_PutItem<WithStreamedUnaryMethod_SortItems<WithStreamedUnaryMethod_GetNearestItems<WithStreamedUnaryMethod_UseItem<WithStreamedUnaryMethod_GetServiceStatus<WithStreamedUnaryMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateItem<WithStreamedUnaryMethod_GetItem<WithStreamedUnaryMethod_DeleteItem<WithStreamedUnaryMethod_GetItems<WithStreamedUnaryMethod_CreateItemType<WithStreamedUnaryMethod_GetItemType<WithStreamedUnaryMethod_DeleteItemType<WithStreamedUnaryMethod_GetItemTypes<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_GetContainer<WithStreamedUnaryMethod_DeleteContainer<WithStreamedUnaryMethod_GetContainers<WithStreamedUnaryMethod_CreateContainerType<WithStreamedUnaryMethod_GetContainerType<WithStreamedUnaryMethod_DeleteContainerType<WithStreamedUnaryMethod_GetContainerTypes<WithStreamedUnaryMethod_GetContainerItems<WithStreamedUnaryMethod_PullItem<WithStreamedUnaryMethod_PutItem<WithStreamedUnaryMethod_SortItems<WithStreamedUnaryMethod_GetNearestItems<WithStreamedUnaryMethod_UseItem<WithStreamedUnaryMethod_GetServiceStatus<WithStreamedUnaryMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace mruv


#endif  // GRPC_items_2fitems_2eproto__INCLUDED
