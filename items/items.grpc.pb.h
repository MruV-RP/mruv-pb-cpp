// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: items/items.proto
#ifndef GRPC_items_2fitems_2eproto__INCLUDED
#define GRPC_items_2fitems_2eproto__INCLUDED

#include "items/items.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mruv {
namespace items {

// The MruV items service provides procedures for managing items and containers
class MruVItemService final {
 public:
  static constexpr char const* service_full_name() {
    return "mruv.items.MruVItemService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Create new item.
    virtual ::grpc::Status CreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::mruv::ItemID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> AsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(AsyncCreateItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> PrepareAsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(PrepareAsyncCreateItemRaw(context, request, cq));
    }
    // Get item by id.
    virtual ::grpc::Status GetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::Item* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> AsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(AsyncGetItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> PrepareAsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(PrepareAsyncGetItemRaw(context, request, cq));
    }
    // Delete item by id.
    virtual ::grpc::Status DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::ItemID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> AsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(AsyncDeleteItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>> PrepareAsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>>(PrepareAsyncDeleteItemRaw(context, request, cq));
    }
    // Gets all items.
    virtual ::grpc::Status GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::mruv::items::GetItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemsResponse>> AsyncGetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemsResponse>>(AsyncGetItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemsResponse>> PrepareAsyncGetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemsResponse>>(PrepareAsyncGetItemsRaw(context, request, cq));
    }
    // Create item type.
    virtual ::grpc::Status CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::mruv::ItemTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> AsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(AsyncCreateItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> PrepareAsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(PrepareAsyncCreateItemTypeRaw(context, request, cq));
    }
    // Get item type by id.
    virtual ::grpc::Status GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>> AsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>>(AsyncGetItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>> PrepareAsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>>(PrepareAsyncGetItemTypeRaw(context, request, cq));
    }
    // Delete item type by id.
    virtual ::grpc::Status DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> AsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(AsyncDeleteItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>> PrepareAsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>>(PrepareAsyncDeleteItemTypeRaw(context, request, cq));
    }
    // Gets all item types.
    virtual ::grpc::Status GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::mruv::items::GetItemTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemTypesResponse>> AsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemTypesResponse>>(AsyncGetItemTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemTypesResponse>> PrepareAsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemTypesResponse>>(PrepareAsyncGetItemTypesRaw(context, request, cq));
    }
    // Create container.
    virtual ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::mruv::ContainerID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> AsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    // Get container by id.
    virtual ::grpc::Status GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::Container* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>> AsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>>(AsyncGetContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>> PrepareAsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>>(PrepareAsyncGetContainerRaw(context, request, cq));
    }
    // Delete container by id.
    virtual ::grpc::Status DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::ContainerID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> AsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(AsyncDeleteContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>> PrepareAsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>>(PrepareAsyncDeleteContainerRaw(context, request, cq));
    }
    // Get all containers.
    virtual ::grpc::Status GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::mruv::items::GetContainersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainersResponse>> AsyncGetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainersResponse>>(AsyncGetContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainersResponse>> PrepareAsyncGetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainersResponse>>(PrepareAsyncGetContainersRaw(context, request, cq));
    }
    // Create a container type.
    virtual ::grpc::Status CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::mruv::ContainerTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> AsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(AsyncCreateContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> PrepareAsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(PrepareAsyncCreateContainerTypeRaw(context, request, cq));
    }
    // Get a container type by id.
    virtual ::grpc::Status GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>> AsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>>(AsyncGetContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>> PrepareAsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>>(PrepareAsyncGetContainerTypeRaw(context, request, cq));
    }
    // Delete a container type by id.
    virtual ::grpc::Status DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerTypeID* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> AsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(AsyncDeleteContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>> PrepareAsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>>(PrepareAsyncDeleteContainerTypeRaw(context, request, cq));
    }
    // Get all container types.
    virtual ::grpc::Status GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::mruv::items::GetContainerTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerTypesResponse>> AsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerTypesResponse>>(AsyncGetContainerTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerTypesResponse>> PrepareAsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerTypesResponse>>(PrepareAsyncGetContainerTypesRaw(context, request, cq));
    }
    // Get items inside a container.
    virtual ::grpc::Status GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::mruv::items::GetContainerItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerItemsResponse>> AsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerItemsResponse>>(AsyncGetContainerItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerItemsResponse>> PrepareAsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerItemsResponse>>(PrepareAsyncGetContainerItemsRaw(context, request, cq));
    }
    // Pull an item from container.
    virtual ::grpc::Status PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::mruv::Item* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> AsyncPullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(AsyncPullItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>> PrepareAsyncPullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>>(PrepareAsyncPullItemRaw(context, request, cq));
    }
    // Put an item into container.
    virtual ::grpc::Status PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::mruv::items::PutItemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::PutItemResponse>> AsyncPutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::PutItemResponse>>(AsyncPutItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::PutItemResponse>> PrepareAsyncPutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::PutItemResponse>>(PrepareAsyncPutItemRaw(context, request, cq));
    }
    // Sort items inside container.
    // This procedure change order of items inside container.
    virtual ::grpc::Status SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::mruv::items::SortItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::SortItemsResponse>> AsyncSortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::SortItemsResponse>>(AsyncSortItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::SortItemsResponse>> PrepareAsyncSortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::SortItemsResponse>>(PrepareAsyncSortItemsRaw(context, request, cq));
    }
    // Retrieves from the container the list of items nearest to the given position.
    virtual ::grpc::Status GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::mruv::items::GetNearestItemsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetNearestItemsResponse>> AsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetNearestItemsResponse>>(AsyncGetNearestItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetNearestItemsResponse>> PrepareAsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetNearestItemsResponse>>(PrepareAsyncGetNearestItemsRaw(context, request, cq));
    }
    // Trigger action associated with the item usage.
    virtual ::grpc::Status UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::mruv::items::UseItemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::UseItemResponse>> AsyncUseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::UseItemResponse>>(AsyncUseItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::UseItemResponse>> PrepareAsyncUseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::UseItemResponse>>(PrepareAsyncUseItemRaw(context, request, cq));
    }
    // Get service health status.
    virtual ::grpc::Status GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::mruv::ServiceStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>> AsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>>(AsyncGetServiceStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>> PrepareAsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>>(PrepareAsyncGetServiceStatusRaw(context, request, cq));
    }
    // Get service current version.
    virtual ::grpc::Status GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::mruv::VersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>> AsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>>(AsyncGetServiceVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>> PrepareAsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>>(PrepareAsyncGetServiceVersionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Create new item.
      virtual void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get item by id.
      virtual void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete item by id.
      virtual void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Gets all items.
      virtual void GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Create item type.
      virtual void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get item type by id.
      virtual void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete item type by id.
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Gets all item types.
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Create container.
      virtual void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get container by id.
      virtual void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete container by id.
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all containers.
      virtual void GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Create a container type.
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a container type by id.
      virtual void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a container type by id.
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all container types.
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get items inside a container.
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Pull an item from container.
      virtual void PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Put an item into container.
      virtual void PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::PutItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::PutItemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Sort items inside container.
      // This procedure change order of items inside container.
      virtual void SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::SortItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::SortItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Retrieves from the container the list of items nearest to the given position.
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Trigger action associated with the item usage.
      virtual void UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::UseItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::UseItemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get service health status.
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get service current version.
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* AsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* PrepareAsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* AsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* PrepareAsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* AsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemID>* PrepareAsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemsResponse>* AsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemsResponse>* PrepareAsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* AsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* PrepareAsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>* AsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemType>* PrepareAsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* AsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ItemTypeID>* PrepareAsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemTypesResponse>* AsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetItemTypesResponse>* PrepareAsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>* AsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Container>* PrepareAsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* AsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerID>* PrepareAsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainersResponse>* AsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainersResponse>* PrepareAsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* AsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* PrepareAsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>* AsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerType>* PrepareAsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* AsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ContainerTypeID>* PrepareAsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerTypesResponse>* AsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerTypesResponse>* PrepareAsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerItemsResponse>* AsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetContainerItemsResponse>* PrepareAsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* AsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::Item>* PrepareAsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::PutItemResponse>* AsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::PutItemResponse>* PrepareAsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::SortItemsResponse>* AsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::SortItemsResponse>* PrepareAsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetNearestItemsResponse>* AsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::GetNearestItemsResponse>* PrepareAsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::UseItemResponse>* AsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::items::UseItemResponse>* PrepareAsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>* AsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::ServiceStatusResponse>* PrepareAsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>* AsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::VersionResponse>* PrepareAsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::mruv::ItemID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> AsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(AsyncCreateItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> PrepareAsyncCreateItem(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(PrepareAsyncCreateItemRaw(context, request, cq));
    }
    ::grpc::Status GetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::Item* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> AsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(AsyncGetItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> PrepareAsyncGetItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(PrepareAsyncGetItemRaw(context, request, cq));
    }
    ::grpc::Status DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::mruv::ItemID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> AsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(AsyncDeleteItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>> PrepareAsyncDeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>>(PrepareAsyncDeleteItemRaw(context, request, cq));
    }
    ::grpc::Status GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::mruv::items::GetItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemsResponse>> AsyncGetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemsResponse>>(AsyncGetItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemsResponse>> PrepareAsyncGetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemsResponse>>(PrepareAsyncGetItemsRaw(context, request, cq));
    }
    ::grpc::Status CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::mruv::ItemTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> AsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(AsyncCreateItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> PrepareAsyncCreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(PrepareAsyncCreateItemTypeRaw(context, request, cq));
    }
    ::grpc::Status GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>> AsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>>(AsyncGetItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>> PrepareAsyncGetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>>(PrepareAsyncGetItemTypeRaw(context, request, cq));
    }
    ::grpc::Status DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::mruv::ItemTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> AsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(AsyncDeleteItemTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>> PrepareAsyncDeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>>(PrepareAsyncDeleteItemTypeRaw(context, request, cq));
    }
    ::grpc::Status GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::mruv::items::GetItemTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemTypesResponse>> AsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemTypesResponse>>(AsyncGetItemTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemTypesResponse>> PrepareAsyncGetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemTypesResponse>>(PrepareAsyncGetItemTypesRaw(context, request, cq));
    }
    ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::mruv::ContainerID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> AsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    ::grpc::Status GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::Container* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>> AsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>>(AsyncGetContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>> PrepareAsyncGetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Container>>(PrepareAsyncGetContainerRaw(context, request, cq));
    }
    ::grpc::Status DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::mruv::ContainerID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> AsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(AsyncDeleteContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>> PrepareAsyncDeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>>(PrepareAsyncDeleteContainerRaw(context, request, cq));
    }
    ::grpc::Status GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::mruv::items::GetContainersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainersResponse>> AsyncGetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainersResponse>>(AsyncGetContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainersResponse>> PrepareAsyncGetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainersResponse>>(PrepareAsyncGetContainersRaw(context, request, cq));
    }
    ::grpc::Status CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::mruv::ContainerTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> AsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(AsyncCreateContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> PrepareAsyncCreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(PrepareAsyncCreateContainerTypeRaw(context, request, cq));
    }
    ::grpc::Status GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>> AsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>>(AsyncGetContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>> PrepareAsyncGetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>>(PrepareAsyncGetContainerTypeRaw(context, request, cq));
    }
    ::grpc::Status DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::mruv::ContainerTypeID* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> AsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(AsyncDeleteContainerTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>> PrepareAsyncDeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>>(PrepareAsyncDeleteContainerTypeRaw(context, request, cq));
    }
    ::grpc::Status GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::mruv::items::GetContainerTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerTypesResponse>> AsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerTypesResponse>>(AsyncGetContainerTypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerTypesResponse>> PrepareAsyncGetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerTypesResponse>>(PrepareAsyncGetContainerTypesRaw(context, request, cq));
    }
    ::grpc::Status GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::mruv::items::GetContainerItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerItemsResponse>> AsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerItemsResponse>>(AsyncGetContainerItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerItemsResponse>> PrepareAsyncGetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerItemsResponse>>(PrepareAsyncGetContainerItemsRaw(context, request, cq));
    }
    ::grpc::Status PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::mruv::Item* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> AsyncPullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(AsyncPullItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>> PrepareAsyncPullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::Item>>(PrepareAsyncPullItemRaw(context, request, cq));
    }
    ::grpc::Status PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::mruv::items::PutItemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::PutItemResponse>> AsyncPutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::PutItemResponse>>(AsyncPutItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::PutItemResponse>> PrepareAsyncPutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::PutItemResponse>>(PrepareAsyncPutItemRaw(context, request, cq));
    }
    ::grpc::Status SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::mruv::items::SortItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::SortItemsResponse>> AsyncSortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::SortItemsResponse>>(AsyncSortItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::SortItemsResponse>> PrepareAsyncSortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::SortItemsResponse>>(PrepareAsyncSortItemsRaw(context, request, cq));
    }
    ::grpc::Status GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::mruv::items::GetNearestItemsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetNearestItemsResponse>> AsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetNearestItemsResponse>>(AsyncGetNearestItemsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetNearestItemsResponse>> PrepareAsyncGetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::GetNearestItemsResponse>>(PrepareAsyncGetNearestItemsRaw(context, request, cq));
    }
    ::grpc::Status UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::mruv::items::UseItemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::UseItemResponse>> AsyncUseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::UseItemResponse>>(AsyncUseItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::UseItemResponse>> PrepareAsyncUseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::items::UseItemResponse>>(PrepareAsyncUseItemRaw(context, request, cq));
    }
    ::grpc::Status GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::mruv::ServiceStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>> AsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>>(AsyncGetServiceStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>> PrepareAsyncGetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>>(PrepareAsyncGetServiceStatusRaw(context, request, cq));
    }
    ::grpc::Status GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::mruv::VersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>> AsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>>(AsyncGetServiceVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>> PrepareAsyncGetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>>(PrepareAsyncGetServiceVersionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateItem(::grpc::ClientContext* context, const ::mruv::Item* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteItem(::grpc::ClientContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItems(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateItemType(::grpc::ClientContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) override;
      void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteItemType(::grpc::ClientContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteItemType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ItemTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemTypesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItemTypes(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetItemTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetItemTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateContainer(::grpc::ClientContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) override;
      void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Container* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteContainer(::grpc::ClientContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteContainer(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainers(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateContainerType(::grpc::ClientContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) override;
      void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerType* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteContainerType(::grpc::ClientContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteContainerType(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ContainerTypeID* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerTypesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainerTypes(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainerTypes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerTypesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerItemsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainerItems(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetContainerItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetContainerItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PullItem(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PullItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::Item* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response, std::function<void(::grpc::Status)>) override;
      void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::PutItemResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PutItem(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::PutItemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PutItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::PutItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::SortItemsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SortItems(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::SortItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SortItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::SortItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetNearestItemsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNearestItems(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNearestItems(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::GetNearestItemsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response, std::function<void(::grpc::Status)>) override;
      void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::UseItemResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UseItem(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::UseItemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UseItem(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::items::UseItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetServiceStatus(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetServiceStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::ServiceStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetServiceVersion(::grpc::ClientContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetServiceVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* AsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* PrepareAsyncCreateItemRaw(::grpc::ClientContext* context, const ::mruv::Item& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* AsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* PrepareAsyncGetItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* AsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemID>* PrepareAsyncDeleteItemRaw(::grpc::ClientContext* context, const ::mruv::ItemID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemsResponse>* AsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemsResponse>* PrepareAsyncGetItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* AsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* PrepareAsyncCreateItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>* AsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemType>* PrepareAsyncGetItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* AsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ItemTypeID>* PrepareAsyncDeleteItemTypeRaw(::grpc::ClientContext* context, const ::mruv::ItemTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemTypesResponse>* AsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetItemTypesResponse>* PrepareAsyncGetItemTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetItemTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::mruv::Container& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Container>* AsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Container>* PrepareAsyncGetContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* AsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerID>* PrepareAsyncDeleteContainerRaw(::grpc::ClientContext* context, const ::mruv::ContainerID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainersResponse>* AsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainersResponse>* PrepareAsyncGetContainersRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* AsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* PrepareAsyncCreateContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>* AsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerType>* PrepareAsyncGetContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* AsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ContainerTypeID>* PrepareAsyncDeleteContainerTypeRaw(::grpc::ClientContext* context, const ::mruv::ContainerTypeID& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerTypesResponse>* AsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerTypesResponse>* PrepareAsyncGetContainerTypesRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerItemsResponse>* AsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetContainerItemsResponse>* PrepareAsyncGetContainerItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetContainerItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* AsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::Item>* PrepareAsyncPullItemRaw(::grpc::ClientContext* context, const ::mruv::items::PullItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::PutItemResponse>* AsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::PutItemResponse>* PrepareAsyncPutItemRaw(::grpc::ClientContext* context, const ::mruv::items::PutItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::SortItemsResponse>* AsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::SortItemsResponse>* PrepareAsyncSortItemsRaw(::grpc::ClientContext* context, const ::mruv::items::SortItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetNearestItemsResponse>* AsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::GetNearestItemsResponse>* PrepareAsyncGetNearestItemsRaw(::grpc::ClientContext* context, const ::mruv::items::GetNearestItemsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::UseItemResponse>* AsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::items::UseItemResponse>* PrepareAsyncUseItemRaw(::grpc::ClientContext* context, const ::mruv::items::UseItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>* AsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::ServiceStatusResponse>* PrepareAsyncGetServiceStatusRaw(::grpc::ClientContext* context, const ::mruv::ServiceStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>* AsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::VersionResponse>* PrepareAsyncGetServiceVersionRaw(::grpc::ClientContext* context, const ::mruv::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateItem_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItem_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteItem_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItems_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateItemType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItemType_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteItemType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetItemTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainers_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateContainerType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainerType_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteContainerType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainerTypes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContainerItems_;
    const ::grpc::internal::RpcMethod rpcmethod_PullItem_;
    const ::grpc::internal::RpcMethod rpcmethod_PutItem_;
    const ::grpc::internal::RpcMethod rpcmethod_SortItems_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNearestItems_;
    const ::grpc::internal::RpcMethod rpcmethod_UseItem_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServiceStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServiceVersion_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Create new item.
    virtual ::grpc::Status CreateItem(::grpc::ServerContext* context, const ::mruv::Item* request, ::mruv::ItemID* response);
    // Get item by id.
    virtual ::grpc::Status GetItem(::grpc::ServerContext* context, const ::mruv::ItemID* request, ::mruv::Item* response);
    // Delete item by id.
    virtual ::grpc::Status DeleteItem(::grpc::ServerContext* context, const ::mruv::ItemID* request, ::mruv::ItemID* response);
    // Gets all items.
    virtual ::grpc::Status GetItems(::grpc::ServerContext* context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response);
    // Create item type.
    virtual ::grpc::Status CreateItemType(::grpc::ServerContext* context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response);
    // Get item type by id.
    virtual ::grpc::Status GetItemType(::grpc::ServerContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response);
    // Delete item type by id.
    virtual ::grpc::Status DeleteItemType(::grpc::ServerContext* context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response);
    // Gets all item types.
    virtual ::grpc::Status GetItemTypes(::grpc::ServerContext* context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response);
    // Create container.
    virtual ::grpc::Status CreateContainer(::grpc::ServerContext* context, const ::mruv::Container* request, ::mruv::ContainerID* response);
    // Get container by id.
    virtual ::grpc::Status GetContainer(::grpc::ServerContext* context, const ::mruv::ContainerID* request, ::mruv::Container* response);
    // Delete container by id.
    virtual ::grpc::Status DeleteContainer(::grpc::ServerContext* context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response);
    // Get all containers.
    virtual ::grpc::Status GetContainers(::grpc::ServerContext* context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response);
    // Create a container type.
    virtual ::grpc::Status CreateContainerType(::grpc::ServerContext* context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response);
    // Get a container type by id.
    virtual ::grpc::Status GetContainerType(::grpc::ServerContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response);
    // Delete a container type by id.
    virtual ::grpc::Status DeleteContainerType(::grpc::ServerContext* context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response);
    // Get all container types.
    virtual ::grpc::Status GetContainerTypes(::grpc::ServerContext* context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response);
    // Get items inside a container.
    virtual ::grpc::Status GetContainerItems(::grpc::ServerContext* context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response);
    // Pull an item from container.
    virtual ::grpc::Status PullItem(::grpc::ServerContext* context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response);
    // Put an item into container.
    virtual ::grpc::Status PutItem(::grpc::ServerContext* context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response);
    // Sort items inside container.
    // This procedure change order of items inside container.
    virtual ::grpc::Status SortItems(::grpc::ServerContext* context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response);
    // Retrieves from the container the list of items nearest to the given position.
    virtual ::grpc::Status GetNearestItems(::grpc::ServerContext* context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response);
    // Trigger action associated with the item usage.
    virtual ::grpc::Status UseItem(::grpc::ServerContext* context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response);
    // Get service health status.
    virtual ::grpc::Status GetServiceStatus(::grpc::ServerContext* context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response);
    // Get service current version.
    virtual ::grpc::Status GetServiceVersion(::grpc::ServerContext* context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateItem() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItem(::grpc::ServerContext* context, ::mruv::Item* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItem() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItem(::grpc::ServerContext* context, ::mruv::ItemID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::Item>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteItem() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItem(::grpc::ServerContext* context, ::mruv::ItemID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItems() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItems(::grpc::ServerContext* context, ::mruv::items::GetItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::GetItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateItemType() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItemType(::grpc::ServerContext* context, ::mruv::ItemType* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItemType() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemType(::grpc::ServerContext* context, ::mruv::ItemTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItemType(::grpc::ServerContext* context, ::mruv::ItemTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ItemTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemTypes(::grpc::ServerContext* context, ::mruv::items::GetItemTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::GetItemTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateContainer() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainer(::grpc::ServerContext* context, ::mruv::Container* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainer() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainer(::grpc::ServerContext* context, ::mruv::ContainerID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::Container>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainer(::grpc::ServerContext* context, ::mruv::ContainerID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainers() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainers(::grpc::ServerContext* context, ::mruv::items::GetContainersRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::GetContainersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainerType(::grpc::ServerContext* context, ::mruv::ContainerType* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainerType() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerType(::grpc::ServerContext* context, ::mruv::ContainerTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainerType(::grpc::ServerContext* context, ::mruv::ContainerTypeID* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ContainerTypeID>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerTypes(::grpc::ServerContext* context, ::mruv::items::GetContainerTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::GetContainerTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerItems(::grpc::ServerContext* context, ::mruv::items::GetContainerItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::GetContainerItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PullItem() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPullItem(::grpc::ServerContext* context, ::mruv::items::PullItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::Item>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutItem() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutItem(::grpc::ServerContext* context, ::mruv::items::PutItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::PutItemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SortItems() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSortItems(::grpc::ServerContext* context, ::mruv::items::SortItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::SortItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNearestItems(::grpc::ServerContext* context, ::mruv::items::GetNearestItemsRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::GetNearestItemsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UseItem() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUseItem(::grpc::ServerContext* context, ::mruv::items::UseItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::items::UseItemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceStatus(::grpc::ServerContext* context, ::mruv::ServiceStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::ServiceStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceVersion(::grpc::ServerContext* context, ::mruv::VersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::VersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateItem<WithAsyncMethod_GetItem<WithAsyncMethod_DeleteItem<WithAsyncMethod_GetItems<WithAsyncMethod_CreateItemType<WithAsyncMethod_GetItemType<WithAsyncMethod_DeleteItemType<WithAsyncMethod_GetItemTypes<WithAsyncMethod_CreateContainer<WithAsyncMethod_GetContainer<WithAsyncMethod_DeleteContainer<WithAsyncMethod_GetContainers<WithAsyncMethod_CreateContainerType<WithAsyncMethod_GetContainerType<WithAsyncMethod_DeleteContainerType<WithAsyncMethod_GetContainerTypes<WithAsyncMethod_GetContainerItems<WithAsyncMethod_PullItem<WithAsyncMethod_PutItem<WithAsyncMethod_SortItems<WithAsyncMethod_GetNearestItems<WithAsyncMethod_UseItem<WithAsyncMethod_GetServiceStatus<WithAsyncMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Item, ::mruv::ItemID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::Item* request, ::mruv::ItemID* response) { return this->CreateItem(context, request, response); }));}
    void SetMessageAllocatorFor_CreateItem(
        ::grpc::experimental::MessageAllocator< ::mruv::Item, ::mruv::ItemID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Item, ::mruv::ItemID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateItem(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::Item>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ItemID* request, ::mruv::Item* response) { return this->GetItem(context, request, response); }));}
    void SetMessageAllocatorFor_GetItem(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemID, ::mruv::Item>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::Item>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItem(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::ItemID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ItemID* request, ::mruv::ItemID* response) { return this->DeleteItem(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteItem(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemID, ::mruv::ItemID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemID, ::mruv::ItemID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteItem(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetItemsRequest, ::mruv::items::GetItemsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::GetItemsRequest* request, ::mruv::items::GetItemsResponse* response) { return this->GetItems(context, request, response); }));}
    void SetMessageAllocatorFor_GetItems(
        ::grpc::experimental::MessageAllocator< ::mruv::items::GetItemsRequest, ::mruv::items::GetItemsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetItemsRequest, ::mruv::items::GetItemsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItems(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateItemType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemType, ::mruv::ItemTypeID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ItemType* request, ::mruv::ItemTypeID* response) { return this->CreateItemType(context, request, response); }));}
    void SetMessageAllocatorFor_CreateItemType(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemType, ::mruv::ItemTypeID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemType, ::mruv::ItemTypeID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateItemType(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItemType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItemType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemType>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ItemTypeID* request, ::mruv::ItemType* response) { return this->GetItemType(context, request, response); }));}
    void SetMessageAllocatorFor_GetItemType(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemTypeID, ::mruv::ItemType>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItemType(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteItemType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemTypeID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ItemTypeID* request, ::mruv::ItemTypeID* response) { return this->DeleteItemType(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteItemType(
        ::grpc::experimental::MessageAllocator< ::mruv::ItemTypeID, ::mruv::ItemTypeID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ItemTypeID, ::mruv::ItemTypeID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteItemType(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItemType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetItemTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetItemTypesRequest, ::mruv::items::GetItemTypesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::GetItemTypesRequest* request, ::mruv::items::GetItemTypesResponse* response) { return this->GetItemTypes(context, request, response); }));}
    void SetMessageAllocatorFor_GetItemTypes(
        ::grpc::experimental::MessageAllocator< ::mruv::items::GetItemTypesRequest, ::mruv::items::GetItemTypesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetItemTypesRequest, ::mruv::items::GetItemTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItemTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Container, ::mruv::ContainerID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::Container* request, ::mruv::ContainerID* response) { return this->CreateContainer(context, request, response); }));}
    void SetMessageAllocatorFor_CreateContainer(
        ::grpc::experimental::MessageAllocator< ::mruv::Container, ::mruv::ContainerID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::Container, ::mruv::ContainerID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::Container>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ContainerID* request, ::mruv::Container* response) { return this->GetContainer(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainer(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerID, ::mruv::Container>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::Container>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::ContainerID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ContainerID* request, ::mruv::ContainerID* response) { return this->DeleteContainer(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteContainer(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerID, ::mruv::ContainerID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerID, ::mruv::ContainerID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetContainersRequest, ::mruv::items::GetContainersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::GetContainersRequest* request, ::mruv::items::GetContainersResponse* response) { return this->GetContainers(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainers(
        ::grpc::experimental::MessageAllocator< ::mruv::items::GetContainersRequest, ::mruv::items::GetContainersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetContainersRequest, ::mruv::items::GetContainersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainers(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateContainerType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerType, ::mruv::ContainerTypeID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ContainerType* request, ::mruv::ContainerTypeID* response) { return this->CreateContainerType(context, request, response); }));}
    void SetMessageAllocatorFor_CreateContainerType(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerType, ::mruv::ContainerTypeID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerType, ::mruv::ContainerTypeID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateContainerType(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainerType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainerType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerType>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerType* response) { return this->GetContainerType(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainerType(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerTypeID, ::mruv::ContainerType>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainerType(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteContainerType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ContainerTypeID* request, ::mruv::ContainerTypeID* response) { return this->DeleteContainerType(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteContainerType(
        ::grpc::experimental::MessageAllocator< ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteContainerType(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainerType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainerTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetContainerTypesRequest, ::mruv::items::GetContainerTypesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::GetContainerTypesRequest* request, ::mruv::items::GetContainerTypesResponse* response) { return this->GetContainerTypes(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainerTypes(
        ::grpc::experimental::MessageAllocator< ::mruv::items::GetContainerTypesRequest, ::mruv::items::GetContainerTypesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetContainerTypesRequest, ::mruv::items::GetContainerTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainerTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetContainerItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetContainerItemsRequest, ::mruv::items::GetContainerItemsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::GetContainerItemsRequest* request, ::mruv::items::GetContainerItemsResponse* response) { return this->GetContainerItems(context, request, response); }));}
    void SetMessageAllocatorFor_GetContainerItems(
        ::grpc::experimental::MessageAllocator< ::mruv::items::GetContainerItemsRequest, ::mruv::items::GetContainerItemsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetContainerItemsRequest, ::mruv::items::GetContainerItemsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainerItems(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PullItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::PullItemRequest, ::mruv::Item>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::PullItemRequest* request, ::mruv::Item* response) { return this->PullItem(context, request, response); }));}
    void SetMessageAllocatorFor_PullItem(
        ::grpc::experimental::MessageAllocator< ::mruv::items::PullItemRequest, ::mruv::Item>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::PullItemRequest, ::mruv::Item>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PullItem(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PullItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PutItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::PutItemRequest, ::mruv::items::PutItemResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::PutItemRequest* request, ::mruv::items::PutItemResponse* response) { return this->PutItem(context, request, response); }));}
    void SetMessageAllocatorFor_PutItem(
        ::grpc::experimental::MessageAllocator< ::mruv::items::PutItemRequest, ::mruv::items::PutItemResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::PutItemRequest, ::mruv::items::PutItemResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PutItem(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PutItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SortItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::SortItemsRequest, ::mruv::items::SortItemsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::SortItemsRequest* request, ::mruv::items::SortItemsResponse* response) { return this->SortItems(context, request, response); }));}
    void SetMessageAllocatorFor_SortItems(
        ::grpc::experimental::MessageAllocator< ::mruv::items::SortItemsRequest, ::mruv::items::SortItemsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::SortItemsRequest, ::mruv::items::SortItemsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SortItems(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SortItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNearestItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetNearestItemsRequest, ::mruv::items::GetNearestItemsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::GetNearestItemsRequest* request, ::mruv::items::GetNearestItemsResponse* response) { return this->GetNearestItems(context, request, response); }));}
    void SetMessageAllocatorFor_GetNearestItems(
        ::grpc::experimental::MessageAllocator< ::mruv::items::GetNearestItemsRequest, ::mruv::items::GetNearestItemsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::GetNearestItemsRequest, ::mruv::items::GetNearestItemsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNearestItems(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNearestItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UseItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::UseItemRequest, ::mruv::items::UseItemResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::items::UseItemRequest* request, ::mruv::items::UseItemResponse* response) { return this->UseItem(context, request, response); }));}
    void SetMessageAllocatorFor_UseItem(
        ::grpc::experimental::MessageAllocator< ::mruv::items::UseItemRequest, ::mruv::items::UseItemResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::items::UseItemRequest, ::mruv::items::UseItemResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UseItem(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UseItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetServiceStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::ServiceStatusRequest* request, ::mruv::ServiceStatusResponse* response) { return this->GetServiceStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetServiceStatus(
        ::grpc::experimental::MessageAllocator< ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetServiceStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetServiceVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::VersionRequest, ::mruv::VersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::VersionRequest* request, ::mruv::VersionResponse* response) { return this->GetServiceVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetServiceVersion(
        ::grpc::experimental::MessageAllocator< ::mruv::VersionRequest, ::mruv::VersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::VersionRequest, ::mruv::VersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetServiceVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_CreateItem<ExperimentalWithCallbackMethod_GetItem<ExperimentalWithCallbackMethod_DeleteItem<ExperimentalWithCallbackMethod_GetItems<ExperimentalWithCallbackMethod_CreateItemType<ExperimentalWithCallbackMethod_GetItemType<ExperimentalWithCallbackMethod_DeleteItemType<ExperimentalWithCallbackMethod_GetItemTypes<ExperimentalWithCallbackMethod_CreateContainer<ExperimentalWithCallbackMethod_GetContainer<ExperimentalWithCallbackMethod_DeleteContainer<ExperimentalWithCallbackMethod_GetContainers<ExperimentalWithCallbackMethod_CreateContainerType<ExperimentalWithCallbackMethod_GetContainerType<ExperimentalWithCallbackMethod_DeleteContainerType<ExperimentalWithCallbackMethod_GetContainerTypes<ExperimentalWithCallbackMethod_GetContainerItems<ExperimentalWithCallbackMethod_PullItem<ExperimentalWithCallbackMethod_PutItem<ExperimentalWithCallbackMethod_SortItems<ExperimentalWithCallbackMethod_GetNearestItems<ExperimentalWithCallbackMethod_UseItem<ExperimentalWithCallbackMethod_GetServiceStatus<ExperimentalWithCallbackMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_CreateItem<ExperimentalWithCallbackMethod_GetItem<ExperimentalWithCallbackMethod_DeleteItem<ExperimentalWithCallbackMethod_GetItems<ExperimentalWithCallbackMethod_CreateItemType<ExperimentalWithCallbackMethod_GetItemType<ExperimentalWithCallbackMethod_DeleteItemType<ExperimentalWithCallbackMethod_GetItemTypes<ExperimentalWithCallbackMethod_CreateContainer<ExperimentalWithCallbackMethod_GetContainer<ExperimentalWithCallbackMethod_DeleteContainer<ExperimentalWithCallbackMethod_GetContainers<ExperimentalWithCallbackMethod_CreateContainerType<ExperimentalWithCallbackMethod_GetContainerType<ExperimentalWithCallbackMethod_DeleteContainerType<ExperimentalWithCallbackMethod_GetContainerTypes<ExperimentalWithCallbackMethod_GetContainerItems<ExperimentalWithCallbackMethod_PullItem<ExperimentalWithCallbackMethod_PutItem<ExperimentalWithCallbackMethod_SortItems<ExperimentalWithCallbackMethod_GetNearestItems<ExperimentalWithCallbackMethod_UseItem<ExperimentalWithCallbackMethod_GetServiceStatus<ExperimentalWithCallbackMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateItem() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItem() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteItem() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItems() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateItemType() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItemType() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateContainer() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainer() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainers() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainerType() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PullItem() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutItem() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SortItems() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UseItem() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateItem() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItem() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteItem() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItems() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateItemType() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateItemType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItemType() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteItemType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetItemTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateContainer() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainer() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainers() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainerType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainerType() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteContainerType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerTypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContainerItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PullItem() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPullItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutItem() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SortItems() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSortItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNearestItems(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UseItem() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUseItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServiceVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateItem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteItem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItems(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateItemType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateItemType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateItemType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateItemType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItemType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItemType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItemType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteItemType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteItemType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteItemType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteItemType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetItemTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetItemTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetItemTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetItemTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateContainer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteContainer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateContainerType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateContainerType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateContainerType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateContainerType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainerType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainerType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainerType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteContainerType() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteContainerType(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteContainerType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteContainerType(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainerTypes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainerTypes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainerTypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerTypes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetContainerItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContainerItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetContainerItems(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetContainerItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PullItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PullItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PullItem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PullItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PutItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PutItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PutItem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PutItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SortItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SortItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SortItems(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SortItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNearestItems() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNearestItems(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNearestItems(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNearestItems(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UseItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UseItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UseItem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UseItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetServiceStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServiceStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetServiceStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetServiceVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServiceVersion(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetServiceVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetServiceVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateItem() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::Item, ::mruv::ItemID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::Item, ::mruv::ItemID>* streamer) {
                       return this->StreamedCreateItem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateItem(::grpc::ServerContext* /*context*/, const ::mruv::Item* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::Item,::mruv::ItemID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItem() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ItemID, ::mruv::Item>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ItemID, ::mruv::Item>* streamer) {
                       return this->StreamedGetItem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemID,::mruv::Item>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteItem() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ItemID, ::mruv::ItemID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ItemID, ::mruv::ItemID>* streamer) {
                       return this->StreamedDeleteItem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteItem(::grpc::ServerContext* /*context*/, const ::mruv::ItemID* /*request*/, ::mruv::ItemID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemID,::mruv::ItemID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItems() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::GetItemsRequest, ::mruv::items::GetItemsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::GetItemsRequest, ::mruv::items::GetItemsResponse>* streamer) {
                       return this->StreamedGetItems(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemsRequest* /*request*/, ::mruv::items::GetItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::GetItemsRequest,::mruv::items::GetItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateItemType() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ItemType, ::mruv::ItemTypeID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ItemType, ::mruv::ItemTypeID>* streamer) {
                       return this->StreamedCreateItemType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemType* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateItemType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemType,::mruv::ItemTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItemType() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ItemTypeID, ::mruv::ItemType>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ItemTypeID, ::mruv::ItemType>* streamer) {
                       return this->StreamedGetItemType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItemType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemTypeID,::mruv::ItemType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteItemType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteItemType() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ItemTypeID, ::mruv::ItemTypeID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ItemTypeID, ::mruv::ItemTypeID>* streamer) {
                       return this->StreamedDeleteItemType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteItemType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteItemType(::grpc::ServerContext* /*context*/, const ::mruv::ItemTypeID* /*request*/, ::mruv::ItemTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteItemType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ItemTypeID,::mruv::ItemTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetItemTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetItemTypes() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::GetItemTypesRequest, ::mruv::items::GetItemTypesResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::GetItemTypesRequest, ::mruv::items::GetItemTypesResponse>* streamer) {
                       return this->StreamedGetItemTypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetItemTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetItemTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetItemTypesRequest* /*request*/, ::mruv::items::GetItemTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetItemTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::GetItemTypesRequest,::mruv::items::GetItemTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateContainer() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::Container, ::mruv::ContainerID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::Container, ::mruv::ContainerID>* streamer) {
                       return this->StreamedCreateContainer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* /*context*/, const ::mruv::Container* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::Container,::mruv::ContainerID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainer() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ContainerID, ::mruv::Container>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ContainerID, ::mruv::Container>* streamer) {
                       return this->StreamedGetContainer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::Container* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerID,::mruv::Container>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteContainer() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ContainerID, ::mruv::ContainerID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ContainerID, ::mruv::ContainerID>* streamer) {
                       return this->StreamedDeleteContainer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteContainer(::grpc::ServerContext* /*context*/, const ::mruv::ContainerID* /*request*/, ::mruv::ContainerID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerID,::mruv::ContainerID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainers() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::GetContainersRequest, ::mruv::items::GetContainersResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::GetContainersRequest, ::mruv::items::GetContainersResponse>* streamer) {
                       return this->StreamedGetContainers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainers(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainersRequest* /*request*/, ::mruv::items::GetContainersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::GetContainersRequest,::mruv::items::GetContainersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateContainerType() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ContainerType, ::mruv::ContainerTypeID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ContainerType, ::mruv::ContainerTypeID>* streamer) {
                       return this->StreamedCreateContainerType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerType* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateContainerType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerType,::mruv::ContainerTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainerType() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ContainerTypeID, ::mruv::ContainerType>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ContainerTypeID, ::mruv::ContainerType>* streamer) {
                       return this->StreamedGetContainerType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainerType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerTypeID,::mruv::ContainerType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteContainerType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteContainerType() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ContainerTypeID, ::mruv::ContainerTypeID>* streamer) {
                       return this->StreamedDeleteContainerType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteContainerType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteContainerType(::grpc::ServerContext* /*context*/, const ::mruv::ContainerTypeID* /*request*/, ::mruv::ContainerTypeID* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteContainerType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ContainerTypeID,::mruv::ContainerTypeID>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainerTypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainerTypes() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::GetContainerTypesRequest, ::mruv::items::GetContainerTypesResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::GetContainerTypesRequest, ::mruv::items::GetContainerTypesResponse>* streamer) {
                       return this->StreamedGetContainerTypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetContainerTypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainerTypes(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerTypesRequest* /*request*/, ::mruv::items::GetContainerTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainerTypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::GetContainerTypesRequest,::mruv::items::GetContainerTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContainerItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContainerItems() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::GetContainerItemsRequest, ::mruv::items::GetContainerItemsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::GetContainerItemsRequest, ::mruv::items::GetContainerItemsResponse>* streamer) {
                       return this->StreamedGetContainerItems(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetContainerItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContainerItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetContainerItemsRequest* /*request*/, ::mruv::items::GetContainerItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContainerItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::GetContainerItemsRequest,::mruv::items::GetContainerItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PullItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PullItem() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::PullItemRequest, ::mruv::Item>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::PullItemRequest, ::mruv::Item>* streamer) {
                       return this->StreamedPullItem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PullItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PullItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PullItemRequest* /*request*/, ::mruv::Item* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPullItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::PullItemRequest,::mruv::Item>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutItem() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::PutItemRequest, ::mruv::items::PutItemResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::PutItemRequest, ::mruv::items::PutItemResponse>* streamer) {
                       return this->StreamedPutItem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PutItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutItem(::grpc::ServerContext* /*context*/, const ::mruv::items::PutItemRequest* /*request*/, ::mruv::items::PutItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::PutItemRequest,::mruv::items::PutItemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SortItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SortItems() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::SortItemsRequest, ::mruv::items::SortItemsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::SortItemsRequest, ::mruv::items::SortItemsResponse>* streamer) {
                       return this->StreamedSortItems(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SortItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SortItems(::grpc::ServerContext* /*context*/, const ::mruv::items::SortItemsRequest* /*request*/, ::mruv::items::SortItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSortItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::SortItemsRequest,::mruv::items::SortItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNearestItems : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNearestItems() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::GetNearestItemsRequest, ::mruv::items::GetNearestItemsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::GetNearestItemsRequest, ::mruv::items::GetNearestItemsResponse>* streamer) {
                       return this->StreamedGetNearestItems(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetNearestItems() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNearestItems(::grpc::ServerContext* /*context*/, const ::mruv::items::GetNearestItemsRequest* /*request*/, ::mruv::items::GetNearestItemsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNearestItems(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::GetNearestItemsRequest,::mruv::items::GetNearestItemsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UseItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UseItem() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::items::UseItemRequest, ::mruv::items::UseItemResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::items::UseItemRequest, ::mruv::items::UseItemResponse>* streamer) {
                       return this->StreamedUseItem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UseItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UseItem(::grpc::ServerContext* /*context*/, const ::mruv::items::UseItemRequest* /*request*/, ::mruv::items::UseItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUseItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::items::UseItemRequest,::mruv::items::UseItemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServiceStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServiceStatus() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::ServiceStatusRequest, ::mruv::ServiceStatusResponse>* streamer) {
                       return this->StreamedGetServiceStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServiceStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServiceStatus(::grpc::ServerContext* /*context*/, const ::mruv::ServiceStatusRequest* /*request*/, ::mruv::ServiceStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServiceStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::ServiceStatusRequest,::mruv::ServiceStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServiceVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServiceVersion() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mruv::VersionRequest, ::mruv::VersionResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::mruv::VersionRequest, ::mruv::VersionResponse>* streamer) {
                       return this->StreamedGetServiceVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServiceVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServiceVersion(::grpc::ServerContext* /*context*/, const ::mruv::VersionRequest* /*request*/, ::mruv::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServiceVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::VersionRequest,::mruv::VersionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateItem<WithStreamedUnaryMethod_GetItem<WithStreamedUnaryMethod_DeleteItem<WithStreamedUnaryMethod_GetItems<WithStreamedUnaryMethod_CreateItemType<WithStreamedUnaryMethod_GetItemType<WithStreamedUnaryMethod_DeleteItemType<WithStreamedUnaryMethod_GetItemTypes<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_GetContainer<WithStreamedUnaryMethod_DeleteContainer<WithStreamedUnaryMethod_GetContainers<WithStreamedUnaryMethod_CreateContainerType<WithStreamedUnaryMethod_GetContainerType<WithStreamedUnaryMethod_DeleteContainerType<WithStreamedUnaryMethod_GetContainerTypes<WithStreamedUnaryMethod_GetContainerItems<WithStreamedUnaryMethod_PullItem<WithStreamedUnaryMethod_PutItem<WithStreamedUnaryMethod_SortItems<WithStreamedUnaryMethod_GetNearestItems<WithStreamedUnaryMethod_UseItem<WithStreamedUnaryMethod_GetServiceStatus<WithStreamedUnaryMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateItem<WithStreamedUnaryMethod_GetItem<WithStreamedUnaryMethod_DeleteItem<WithStreamedUnaryMethod_GetItems<WithStreamedUnaryMethod_CreateItemType<WithStreamedUnaryMethod_GetItemType<WithStreamedUnaryMethod_DeleteItemType<WithStreamedUnaryMethod_GetItemTypes<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_GetContainer<WithStreamedUnaryMethod_DeleteContainer<WithStreamedUnaryMethod_GetContainers<WithStreamedUnaryMethod_CreateContainerType<WithStreamedUnaryMethod_GetContainerType<WithStreamedUnaryMethod_DeleteContainerType<WithStreamedUnaryMethod_GetContainerTypes<WithStreamedUnaryMethod_GetContainerItems<WithStreamedUnaryMethod_PullItem<WithStreamedUnaryMethod_PutItem<WithStreamedUnaryMethod_SortItems<WithStreamedUnaryMethod_GetNearestItems<WithStreamedUnaryMethod_UseItem<WithStreamedUnaryMethod_GetServiceStatus<WithStreamedUnaryMethod_GetServiceVersion<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace items
}  // namespace mruv


#endif  // GRPC_items_2fitems_2eproto__INCLUDED
