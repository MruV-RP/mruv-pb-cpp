// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: estates/estates.proto
#ifndef GRPC_estates_2festates_2eproto__INCLUDED
#define GRPC_estates_2festates_2eproto__INCLUDED

#include "estates/estates.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mruv {
namespace estates {

// The MruV estate service provides procedures for managing buildings and other estates.
class MruVEstateService final {
 public:
  static constexpr char const* service_full_name() {
    return "mruv.estates.MruVEstateService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Create real estate.
    virtual ::grpc::Status CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::mruv::estates::CreateEstateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::CreateEstateResponse>> AsyncCreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::CreateEstateResponse>>(AsyncCreateEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::CreateEstateResponse>> PrepareAsyncCreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::CreateEstateResponse>>(PrepareAsyncCreateEstateRaw(context, request, cq));
    }
    // Get real estate.
    virtual ::grpc::Status GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::mruv::estates::Estate* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::Estate>> AsyncGetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::Estate>>(AsyncGetEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::Estate>> PrepareAsyncGetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::Estate>>(PrepareAsyncGetEstateRaw(context, request, cq));
    }
    // Update real estate.
    virtual ::grpc::Status UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::mruv::estates::UpdateEstateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::UpdateEstateResponse>> AsyncUpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::UpdateEstateResponse>>(AsyncUpdateEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::UpdateEstateResponse>> PrepareAsyncUpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::UpdateEstateResponse>>(PrepareAsyncUpdateEstateRaw(context, request, cq));
    }
    // Delete real estate.
    virtual ::grpc::Status DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::mruv::estates::DeleteEstateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteEstateResponse>> AsyncDeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteEstateResponse>>(AsyncDeleteEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteEstateResponse>> PrepareAsyncDeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteEstateResponse>>(PrepareAsyncDeleteEstateRaw(context, request, cq));
    }
    // Get all created real estates.
    virtual ::grpc::Status GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::mruv::estates::GetEstatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstatesResponse>> AsyncGetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstatesResponse>>(AsyncGetEstatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstatesResponse>> PrepareAsyncGetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstatesResponse>>(PrepareAsyncGetEstatesRaw(context, request, cq));
    }
    // Add a gate to an estate.
    virtual ::grpc::Status AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::mruv::estates::AddGateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddGateResponse>> AsyncAddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddGateResponse>>(AsyncAddGateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddGateResponse>> PrepareAsyncAddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddGateResponse>>(PrepareAsyncAddGateRaw(context, request, cq));
    }
    // Delete a gate from estate.
    virtual ::grpc::Status DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::mruv::estates::DeleteGateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteGateResponse>> AsyncDeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteGateResponse>>(AsyncDeleteGateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteGateResponse>> PrepareAsyncDeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteGateResponse>>(PrepareAsyncDeleteGateRaw(context, request, cq));
    }
    // Get all estate gates.
    virtual ::grpc::Status GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::mruv::estates::GetEstateGatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateGatesResponse>> AsyncGetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateGatesResponse>>(AsyncGetEstateGatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateGatesResponse>> PrepareAsyncGetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateGatesResponse>>(PrepareAsyncGetEstateGatesRaw(context, request, cq));
    }
    // Add an entrance to estate.
    virtual ::grpc::Status AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::mruv::estates::AddEntranceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddEntranceResponse>> AsyncAddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddEntranceResponse>>(AsyncAddEntranceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddEntranceResponse>> PrepareAsyncAddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddEntranceResponse>>(PrepareAsyncAddEntranceRaw(context, request, cq));
    }
    // Remove an entrance from estate.
    virtual ::grpc::Status RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::mruv::estates::RemoveEntranceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::RemoveEntranceResponse>> AsyncRemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::RemoveEntranceResponse>>(AsyncRemoveEntranceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::RemoveEntranceResponse>> PrepareAsyncRemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::RemoveEntranceResponse>>(PrepareAsyncRemoveEntranceRaw(context, request, cq));
    }
    // Get all estate entrances.
    virtual ::grpc::Status GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::mruv::estates::GetEstateEntrancesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateEntrancesResponse>> AsyncGetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateEntrancesResponse>>(AsyncGetEstateEntrancesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateEntrancesResponse>> PrepareAsyncGetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateEntrancesResponse>>(PrepareAsyncGetEstateEntrancesRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Create real estate.
      virtual void CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::CreateEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get real estate.
      virtual void GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::Estate* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::Estate* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::Estate* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Update real estate.
      virtual void UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::UpdateEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete real estate.
      virtual void DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteEstateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all created real estates.
      virtual void GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEstates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a gate to an estate.
      virtual void AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddGateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddGateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a gate from estate.
      virtual void DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteGateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all estate gates.
      virtual void GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEstateGates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateGatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstateGates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstateGates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add an entrance to estate.
      virtual void AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddEntranceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove an entrance from estate.
      virtual void RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::RemoveEntranceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all estate entrances.
      virtual void GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEstateEntrances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateEntrancesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEstateEntrances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEstateEntrances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::CreateEstateResponse>* AsyncCreateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::CreateEstateResponse>* PrepareAsyncCreateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::Estate>* AsyncGetEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::Estate>* PrepareAsyncGetEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::UpdateEstateResponse>* AsyncUpdateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::UpdateEstateResponse>* PrepareAsyncUpdateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteEstateResponse>* AsyncDeleteEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteEstateResponse>* PrepareAsyncDeleteEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstatesResponse>* AsyncGetEstatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstatesResponse>* PrepareAsyncGetEstatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddGateResponse>* AsyncAddGateRaw(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddGateResponse>* PrepareAsyncAddGateRaw(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteGateResponse>* AsyncDeleteGateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::DeleteGateResponse>* PrepareAsyncDeleteGateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateGatesResponse>* AsyncGetEstateGatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateGatesResponse>* PrepareAsyncGetEstateGatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddEntranceResponse>* AsyncAddEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::AddEntranceResponse>* PrepareAsyncAddEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::RemoveEntranceResponse>* AsyncRemoveEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::RemoveEntranceResponse>* PrepareAsyncRemoveEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateEntrancesResponse>* AsyncGetEstateEntrancesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mruv::estates::GetEstateEntrancesResponse>* PrepareAsyncGetEstateEntrancesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::mruv::estates::CreateEstateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::CreateEstateResponse>> AsyncCreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::CreateEstateResponse>>(AsyncCreateEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::CreateEstateResponse>> PrepareAsyncCreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::CreateEstateResponse>>(PrepareAsyncCreateEstateRaw(context, request, cq));
    }
    ::grpc::Status GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::mruv::estates::Estate* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::Estate>> AsyncGetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::Estate>>(AsyncGetEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::Estate>> PrepareAsyncGetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::Estate>>(PrepareAsyncGetEstateRaw(context, request, cq));
    }
    ::grpc::Status UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::mruv::estates::UpdateEstateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::UpdateEstateResponse>> AsyncUpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::UpdateEstateResponse>>(AsyncUpdateEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::UpdateEstateResponse>> PrepareAsyncUpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::UpdateEstateResponse>>(PrepareAsyncUpdateEstateRaw(context, request, cq));
    }
    ::grpc::Status DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::mruv::estates::DeleteEstateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteEstateResponse>> AsyncDeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteEstateResponse>>(AsyncDeleteEstateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteEstateResponse>> PrepareAsyncDeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteEstateResponse>>(PrepareAsyncDeleteEstateRaw(context, request, cq));
    }
    ::grpc::Status GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::mruv::estates::GetEstatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstatesResponse>> AsyncGetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstatesResponse>>(AsyncGetEstatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstatesResponse>> PrepareAsyncGetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstatesResponse>>(PrepareAsyncGetEstatesRaw(context, request, cq));
    }
    ::grpc::Status AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::mruv::estates::AddGateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddGateResponse>> AsyncAddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddGateResponse>>(AsyncAddGateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddGateResponse>> PrepareAsyncAddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddGateResponse>>(PrepareAsyncAddGateRaw(context, request, cq));
    }
    ::grpc::Status DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::mruv::estates::DeleteGateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteGateResponse>> AsyncDeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteGateResponse>>(AsyncDeleteGateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteGateResponse>> PrepareAsyncDeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteGateResponse>>(PrepareAsyncDeleteGateRaw(context, request, cq));
    }
    ::grpc::Status GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::mruv::estates::GetEstateGatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateGatesResponse>> AsyncGetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateGatesResponse>>(AsyncGetEstateGatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateGatesResponse>> PrepareAsyncGetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateGatesResponse>>(PrepareAsyncGetEstateGatesRaw(context, request, cq));
    }
    ::grpc::Status AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::mruv::estates::AddEntranceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddEntranceResponse>> AsyncAddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddEntranceResponse>>(AsyncAddEntranceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddEntranceResponse>> PrepareAsyncAddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddEntranceResponse>>(PrepareAsyncAddEntranceRaw(context, request, cq));
    }
    ::grpc::Status RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::mruv::estates::RemoveEntranceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::RemoveEntranceResponse>> AsyncRemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::RemoveEntranceResponse>>(AsyncRemoveEntranceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::RemoveEntranceResponse>> PrepareAsyncRemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::RemoveEntranceResponse>>(PrepareAsyncRemoveEntranceRaw(context, request, cq));
    }
    ::grpc::Status GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::mruv::estates::GetEstateEntrancesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateEntrancesResponse>> AsyncGetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateEntrancesResponse>>(AsyncGetEstateEntrancesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateEntrancesResponse>> PrepareAsyncGetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateEntrancesResponse>>(PrepareAsyncGetEstateEntrancesRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::CreateEstateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateEstate(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::CreateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response, std::function<void(::grpc::Status)>) override;
      void GetEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::Estate* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstate(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::Estate* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::Estate* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::UpdateEstateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateEstate(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::UpdateEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteEstateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteEstate(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteEstate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteEstateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetEstates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstatesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstates(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response, std::function<void(::grpc::Status)>) override;
      void AddGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddGateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddGate(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddGateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteGateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteGate(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteGate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::DeleteGateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetEstateGates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateGatesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstateGates(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstateGates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstateGates(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateGatesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response, std::function<void(::grpc::Status)>) override;
      void AddEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddEntranceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddEntrance(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::AddEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response, std::function<void(::grpc::Status)>) override;
      void RemoveEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::RemoveEntranceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveEntrance(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveEntrance(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::RemoveEntranceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetEstateEntrances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateEntrancesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstateEntrances(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEstateEntrances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEstateEntrances(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::mruv::estates::GetEstateEntrancesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::CreateEstateResponse>* AsyncCreateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::CreateEstateResponse>* PrepareAsyncCreateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::CreateEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::Estate>* AsyncGetEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::Estate>* PrepareAsyncGetEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::UpdateEstateResponse>* AsyncUpdateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::UpdateEstateResponse>* PrepareAsyncUpdateEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::UpdateEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteEstateResponse>* AsyncDeleteEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteEstateResponse>* PrepareAsyncDeleteEstateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteEstateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstatesResponse>* AsyncGetEstatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstatesResponse>* PrepareAsyncGetEstatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddGateResponse>* AsyncAddGateRaw(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddGateResponse>* PrepareAsyncAddGateRaw(::grpc::ClientContext* context, const ::mruv::estates::AddGateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteGateResponse>* AsyncDeleteGateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::DeleteGateResponse>* PrepareAsyncDeleteGateRaw(::grpc::ClientContext* context, const ::mruv::estates::DeleteGateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateGatesResponse>* AsyncGetEstateGatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateGatesResponse>* PrepareAsyncGetEstateGatesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateGatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddEntranceResponse>* AsyncAddEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::AddEntranceResponse>* PrepareAsyncAddEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::AddEntranceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::RemoveEntranceResponse>* AsyncRemoveEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::RemoveEntranceResponse>* PrepareAsyncRemoveEntranceRaw(::grpc::ClientContext* context, const ::mruv::estates::RemoveEntranceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateEntrancesResponse>* AsyncGetEstateEntrancesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mruv::estates::GetEstateEntrancesResponse>* PrepareAsyncGetEstateEntrancesRaw(::grpc::ClientContext* context, const ::mruv::estates::GetEstateEntrancesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateEstate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEstate_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateEstate_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteEstate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEstates_;
    const ::grpc::internal::RpcMethod rpcmethod_AddGate_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteGate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEstateGates_;
    const ::grpc::internal::RpcMethod rpcmethod_AddEntrance_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveEntrance_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEstateEntrances_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Create real estate.
    virtual ::grpc::Status CreateEstate(::grpc::ServerContext* context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response);
    // Get real estate.
    virtual ::grpc::Status GetEstate(::grpc::ServerContext* context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response);
    // Update real estate.
    virtual ::grpc::Status UpdateEstate(::grpc::ServerContext* context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response);
    // Delete real estate.
    virtual ::grpc::Status DeleteEstate(::grpc::ServerContext* context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response);
    // Get all created real estates.
    virtual ::grpc::Status GetEstates(::grpc::ServerContext* context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response);
    // Add a gate to an estate.
    virtual ::grpc::Status AddGate(::grpc::ServerContext* context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response);
    // Delete a gate from estate.
    virtual ::grpc::Status DeleteGate(::grpc::ServerContext* context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response);
    // Get all estate gates.
    virtual ::grpc::Status GetEstateGates(::grpc::ServerContext* context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response);
    // Add an entrance to estate.
    virtual ::grpc::Status AddEntrance(::grpc::ServerContext* context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response);
    // Remove an entrance from estate.
    virtual ::grpc::Status RemoveEntrance(::grpc::ServerContext* context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response);
    // Get all estate entrances.
    virtual ::grpc::Status GetEstateEntrances(::grpc::ServerContext* context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateEstate() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateEstate(::grpc::ServerContext* context, ::mruv::estates::CreateEstateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::CreateEstateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEstate() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstate(::grpc::ServerContext* context, ::mruv::estates::GetEstateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::Estate>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateEstate() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_UpdateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateEstate(::grpc::ServerContext* context, ::mruv::estates::UpdateEstateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::UpdateEstateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteEstate() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DeleteEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteEstate(::grpc::ServerContext* context, ::mruv::estates::DeleteEstateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::DeleteEstateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEstates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEstates() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetEstates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstates(::grpc::ServerContext* context, ::mruv::estates::GetEstatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::GetEstatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddGate() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AddGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddGate(::grpc::ServerContext* context, ::mruv::estates::AddGateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::AddGateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteGate() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGate(::grpc::ServerContext* context, ::mruv::estates::DeleteGateRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::DeleteGateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEstateGates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEstateGates() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetEstateGates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateGates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstateGates(::grpc::ServerContext* context, ::mruv::estates::GetEstateGatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::GetEstateGatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddEntrance() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_AddEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddEntrance(::grpc::ServerContext* context, ::mruv::estates::AddEntranceRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::AddEntranceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveEntrance() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_RemoveEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveEntrance(::grpc::ServerContext* context, ::mruv::estates::RemoveEntranceRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::RemoveEntranceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEstateEntrances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEstateEntrances() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetEstateEntrances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateEntrances(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstateEntrances(::grpc::ServerContext* context, ::mruv::estates::GetEstateEntrancesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mruv::estates::GetEstateEntrancesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateEstate<WithAsyncMethod_GetEstate<WithAsyncMethod_UpdateEstate<WithAsyncMethod_DeleteEstate<WithAsyncMethod_GetEstates<WithAsyncMethod_AddGate<WithAsyncMethod_DeleteGate<WithAsyncMethod_GetEstateGates<WithAsyncMethod_AddEntrance<WithAsyncMethod_RemoveEntrance<WithAsyncMethod_GetEstateEntrances<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::CreateEstateRequest, ::mruv::estates::CreateEstateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::CreateEstateRequest* request, ::mruv::estates::CreateEstateResponse* response) { return this->CreateEstate(context, request, response); }));}
    void SetMessageAllocatorFor_CreateEstate(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::CreateEstateRequest, ::mruv::estates::CreateEstateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::CreateEstateRequest, ::mruv::estates::CreateEstateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstateRequest, ::mruv::estates::Estate>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::GetEstateRequest* request, ::mruv::estates::Estate* response) { return this->GetEstate(context, request, response); }));}
    void SetMessageAllocatorFor_GetEstate(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::GetEstateRequest, ::mruv::estates::Estate>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstateRequest, ::mruv::estates::Estate>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::UpdateEstateRequest, ::mruv::estates::UpdateEstateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::UpdateEstateRequest* request, ::mruv::estates::UpdateEstateResponse* response) { return this->UpdateEstate(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateEstate(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::UpdateEstateRequest, ::mruv::estates::UpdateEstateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::UpdateEstateRequest, ::mruv::estates::UpdateEstateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::DeleteEstateRequest, ::mruv::estates::DeleteEstateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::DeleteEstateRequest* request, ::mruv::estates::DeleteEstateResponse* response) { return this->DeleteEstate(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteEstate(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::DeleteEstateRequest, ::mruv::estates::DeleteEstateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::DeleteEstateRequest, ::mruv::estates::DeleteEstateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEstates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEstates() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstatesRequest, ::mruv::estates::GetEstatesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::GetEstatesRequest* request, ::mruv::estates::GetEstatesResponse* response) { return this->GetEstates(context, request, response); }));}
    void SetMessageAllocatorFor_GetEstates(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::GetEstatesRequest, ::mruv::estates::GetEstatesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstatesRequest, ::mruv::estates::GetEstatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEstates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstates(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstates(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddGate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::AddGateRequest, ::mruv::estates::AddGateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::AddGateRequest* request, ::mruv::estates::AddGateResponse* response) { return this->AddGate(context, request, response); }));}
    void SetMessageAllocatorFor_AddGate(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::AddGateRequest, ::mruv::estates::AddGateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::AddGateRequest, ::mruv::estates::AddGateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddGate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddGate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteGate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::DeleteGateRequest, ::mruv::estates::DeleteGateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::DeleteGateRequest* request, ::mruv::estates::DeleteGateResponse* response) { return this->DeleteGate(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteGate(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::DeleteGateRequest, ::mruv::estates::DeleteGateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::DeleteGateRequest, ::mruv::estates::DeleteGateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGate(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEstateGates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEstateGates() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstateGatesRequest, ::mruv::estates::GetEstateGatesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::GetEstateGatesRequest* request, ::mruv::estates::GetEstateGatesResponse* response) { return this->GetEstateGates(context, request, response); }));}
    void SetMessageAllocatorFor_GetEstateGates(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::GetEstateGatesRequest, ::mruv::estates::GetEstateGatesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstateGatesRequest, ::mruv::estates::GetEstateGatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEstateGates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateGates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstateGates(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstateGates(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddEntrance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::AddEntranceRequest, ::mruv::estates::AddEntranceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::AddEntranceRequest* request, ::mruv::estates::AddEntranceResponse* response) { return this->AddEntrance(context, request, response); }));}
    void SetMessageAllocatorFor_AddEntrance(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::AddEntranceRequest, ::mruv::estates::AddEntranceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::AddEntranceRequest, ::mruv::estates::AddEntranceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddEntrance(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddEntrance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoveEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoveEntrance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::RemoveEntranceRequest, ::mruv::estates::RemoveEntranceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::RemoveEntranceRequest* request, ::mruv::estates::RemoveEntranceResponse* response) { return this->RemoveEntrance(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveEntrance(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::RemoveEntranceRequest, ::mruv::estates::RemoveEntranceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::RemoveEntranceRequest, ::mruv::estates::RemoveEntranceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemoveEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveEntrance(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveEntrance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEstateEntrances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEstateEntrances() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstateEntrancesRequest, ::mruv::estates::GetEstateEntrancesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mruv::estates::GetEstateEntrancesRequest* request, ::mruv::estates::GetEstateEntrancesResponse* response) { return this->GetEstateEntrances(context, request, response); }));}
    void SetMessageAllocatorFor_GetEstateEntrances(
        ::grpc::experimental::MessageAllocator< ::mruv::estates::GetEstateEntrancesRequest, ::mruv::estates::GetEstateEntrancesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::mruv::estates::GetEstateEntrancesRequest, ::mruv::estates::GetEstateEntrancesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEstateEntrances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateEntrances(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstateEntrances(
      ::grpc::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstateEntrances(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_CreateEstate<ExperimentalWithCallbackMethod_GetEstate<ExperimentalWithCallbackMethod_UpdateEstate<ExperimentalWithCallbackMethod_DeleteEstate<ExperimentalWithCallbackMethod_GetEstates<ExperimentalWithCallbackMethod_AddGate<ExperimentalWithCallbackMethod_DeleteGate<ExperimentalWithCallbackMethod_GetEstateGates<ExperimentalWithCallbackMethod_AddEntrance<ExperimentalWithCallbackMethod_RemoveEntrance<ExperimentalWithCallbackMethod_GetEstateEntrances<Service > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_CreateEstate<ExperimentalWithCallbackMethod_GetEstate<ExperimentalWithCallbackMethod_UpdateEstate<ExperimentalWithCallbackMethod_DeleteEstate<ExperimentalWithCallbackMethod_GetEstates<ExperimentalWithCallbackMethod_AddGate<ExperimentalWithCallbackMethod_DeleteGate<ExperimentalWithCallbackMethod_GetEstateGates<ExperimentalWithCallbackMethod_AddEntrance<ExperimentalWithCallbackMethod_RemoveEntrance<ExperimentalWithCallbackMethod_GetEstateEntrances<Service > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateEstate() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEstate() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateEstate() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_UpdateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteEstate() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DeleteEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEstates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEstates() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetEstates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddGate() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AddGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteGate() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEstateGates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEstateGates() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetEstateGates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateGates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddEntrance() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_AddEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveEntrance() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_RemoveEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEstateEntrances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEstateEntrances() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetEstateEntrances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateEntrances(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateEstate() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateEstate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEstate() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateEstate() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_UpdateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateEstate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteEstate() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DeleteEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteEstate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEstates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEstates() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetEstates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstates(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddGate() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AddGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddGate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteGate() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEstateGates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEstateGates() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetEstateGates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateGates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstateGates(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddEntrance() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_AddEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddEntrance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveEntrance() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_RemoveEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveEntrance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEstateEntrances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEstateEntrances() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetEstateEntrances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateEntrances(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEstateEntrances(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateEstate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEstate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateEstate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteEstate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteEstate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteEstate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteEstate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEstates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEstates() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEstates(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEstates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstates(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstates(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddGate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddGate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddGate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddGate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteGate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteGate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEstateGates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEstateGates() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEstateGates(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEstateGates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateGates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstateGates(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstateGates(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddEntrance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddEntrance(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddEntrance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddEntrance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoveEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoveEntrance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveEntrance(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoveEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveEntrance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveEntrance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEstateEntrances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEstateEntrances() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEstateEntrances(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEstateEntrances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEstateEntrances(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEstateEntrances(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEstateEntrances(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateEstate() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::CreateEstateRequest, ::mruv::estates::CreateEstateResponse>(std::bind(&WithStreamedUnaryMethod_CreateEstate<BaseClass>::StreamedCreateEstate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::CreateEstateRequest* /*request*/, ::mruv::estates::CreateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateEstate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::CreateEstateRequest,::mruv::estates::CreateEstateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEstate() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::GetEstateRequest, ::mruv::estates::Estate>(std::bind(&WithStreamedUnaryMethod_GetEstate<BaseClass>::StreamedGetEstate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateRequest* /*request*/, ::mruv::estates::Estate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEstate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::GetEstateRequest,::mruv::estates::Estate>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateEstate() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::UpdateEstateRequest, ::mruv::estates::UpdateEstateResponse>(std::bind(&WithStreamedUnaryMethod_UpdateEstate<BaseClass>::StreamedUpdateEstate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::UpdateEstateRequest* /*request*/, ::mruv::estates::UpdateEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateEstate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::UpdateEstateRequest,::mruv::estates::UpdateEstateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteEstate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteEstate() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::DeleteEstateRequest, ::mruv::estates::DeleteEstateResponse>(std::bind(&WithStreamedUnaryMethod_DeleteEstate<BaseClass>::StreamedDeleteEstate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteEstate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteEstate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteEstateRequest* /*request*/, ::mruv::estates::DeleteEstateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteEstate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::DeleteEstateRequest,::mruv::estates::DeleteEstateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEstates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEstates() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::GetEstatesRequest, ::mruv::estates::GetEstatesResponse>(std::bind(&WithStreamedUnaryMethod_GetEstates<BaseClass>::StreamedGetEstates, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEstates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEstates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstatesRequest* /*request*/, ::mruv::estates::GetEstatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEstates(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::GetEstatesRequest,::mruv::estates::GetEstatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddGate() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::AddGateRequest, ::mruv::estates::AddGateResponse>(std::bind(&WithStreamedUnaryMethod_AddGate<BaseClass>::StreamedAddGate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AddGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddGateRequest* /*request*/, ::mruv::estates::AddGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddGate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::AddGateRequest,::mruv::estates::AddGateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteGate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteGate() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::DeleteGateRequest, ::mruv::estates::DeleteGateResponse>(std::bind(&WithStreamedUnaryMethod_DeleteGate<BaseClass>::StreamedDeleteGate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteGate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteGate(::grpc::ServerContext* /*context*/, const ::mruv::estates::DeleteGateRequest* /*request*/, ::mruv::estates::DeleteGateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteGate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::DeleteGateRequest,::mruv::estates::DeleteGateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEstateGates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEstateGates() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::GetEstateGatesRequest, ::mruv::estates::GetEstateGatesResponse>(std::bind(&WithStreamedUnaryMethod_GetEstateGates<BaseClass>::StreamedGetEstateGates, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEstateGates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEstateGates(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateGatesRequest* /*request*/, ::mruv::estates::GetEstateGatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEstateGates(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::GetEstateGatesRequest,::mruv::estates::GetEstateGatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddEntrance() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::AddEntranceRequest, ::mruv::estates::AddEntranceResponse>(std::bind(&WithStreamedUnaryMethod_AddEntrance<BaseClass>::StreamedAddEntrance, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AddEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::AddEntranceRequest* /*request*/, ::mruv::estates::AddEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddEntrance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::AddEntranceRequest,::mruv::estates::AddEntranceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveEntrance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveEntrance() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::RemoveEntranceRequest, ::mruv::estates::RemoveEntranceResponse>(std::bind(&WithStreamedUnaryMethod_RemoveEntrance<BaseClass>::StreamedRemoveEntrance, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RemoveEntrance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveEntrance(::grpc::ServerContext* /*context*/, const ::mruv::estates::RemoveEntranceRequest* /*request*/, ::mruv::estates::RemoveEntranceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveEntrance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::RemoveEntranceRequest,::mruv::estates::RemoveEntranceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEstateEntrances : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEstateEntrances() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::mruv::estates::GetEstateEntrancesRequest, ::mruv::estates::GetEstateEntrancesResponse>(std::bind(&WithStreamedUnaryMethod_GetEstateEntrances<BaseClass>::StreamedGetEstateEntrances, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetEstateEntrances() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEstateEntrances(::grpc::ServerContext* /*context*/, const ::mruv::estates::GetEstateEntrancesRequest* /*request*/, ::mruv::estates::GetEstateEntrancesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEstateEntrances(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mruv::estates::GetEstateEntrancesRequest,::mruv::estates::GetEstateEntrancesResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateEstate<WithStreamedUnaryMethod_GetEstate<WithStreamedUnaryMethod_UpdateEstate<WithStreamedUnaryMethod_DeleteEstate<WithStreamedUnaryMethod_GetEstates<WithStreamedUnaryMethod_AddGate<WithStreamedUnaryMethod_DeleteGate<WithStreamedUnaryMethod_GetEstateGates<WithStreamedUnaryMethod_AddEntrance<WithStreamedUnaryMethod_RemoveEntrance<WithStreamedUnaryMethod_GetEstateEntrances<Service > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateEstate<WithStreamedUnaryMethod_GetEstate<WithStreamedUnaryMethod_UpdateEstate<WithStreamedUnaryMethod_DeleteEstate<WithStreamedUnaryMethod_GetEstates<WithStreamedUnaryMethod_AddGate<WithStreamedUnaryMethod_DeleteGate<WithStreamedUnaryMethod_GetEstateGates<WithStreamedUnaryMethod_AddEntrance<WithStreamedUnaryMethod_RemoveEntrance<WithStreamedUnaryMethod_GetEstateEntrances<Service > > > > > > > > > > > StreamedService;
};

}  // namespace estates
}  // namespace mruv


#endif  // GRPC_estates_2festates_2eproto__INCLUDED
